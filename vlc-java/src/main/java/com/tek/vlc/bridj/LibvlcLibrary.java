package com.tek.vlc.bridj;

import java.util.Collections;
import java.util.Iterator;
import org.bridj.BridJ;
import org.bridj.CRuntime;
import org.bridj.Callback;
import org.bridj.FlagSet;
import org.bridj.IntValuedEnum;
import org.bridj.Pointer;
import org.bridj.ann.Library;
import org.bridj.ann.Ptr;
import org.bridj.ann.Runtime;
/**
 * Wrapper for library <b>libvlc</b><br>
 * This file was autogenerated by <a href="http://jnaerator.googlecode.com/">JNAerator</a>,<br>
 * a tool written by <a href="http://ochafik.com/">Olivier Chafik</a> that <a href="http://code.google.com/p/jnaerator/wiki/CreditsAndLicense">uses a few opensource projects.</a>.<br>
 * For help, please visit <a href="http://nativelibs4java.googlecode.com/">NativeLibs4Java</a> or <a href="http://bridj.googlecode.com/">BridJ</a> .
 */
@Library("libvlc") 
@Runtime(CRuntime.class) 
public class LibvlcLibrary {
    static {
        BridJ.register();
    }
    /**
     * Logging messages level.<br>
     * \note Future LibVLC versions may define new levels.<br>
     * enum values<br>
     * <i>native declaration : line 414</i>
     */
    public enum libvlc_log_level implements IntValuedEnum<libvlc_log_level > {
        /** < Debug message */
        LIBVLC_DEBUG(0),
        /** < Important informational message */
        LIBVLC_NOTICE(2),
        /** < Warning (potential error) message */
        LIBVLC_WARNING(3),
        /** < Error message */
        LIBVLC_ERROR(4);
        libvlc_log_level(long value) {
            this.value = value;
        }
        public final long value;
        public long value() {
            return this.value;
        }
        public Iterator<libvlc_log_level > iterator() {
            return Collections.singleton(this).iterator();
        }
        public static IntValuedEnum<libvlc_log_level > fromValue(int value) {
            return FlagSet.fromValue(value, values());
        }
    };
    /** enum values */
    public enum libvlc_meta_t implements IntValuedEnum<libvlc_meta_t > {
        libvlc_meta_Title(0),
        libvlc_meta_Artist(1),
        libvlc_meta_Genre(2),
        libvlc_meta_Copyright(3),
        libvlc_meta_Album(4),
        libvlc_meta_TrackNumber(5),
        libvlc_meta_Description(6),
        libvlc_meta_Rating(7),
        libvlc_meta_Date(8),
        libvlc_meta_Setting(9),
        libvlc_meta_URL(10),
        libvlc_meta_Language(11),
        libvlc_meta_NowPlaying(12),
        libvlc_meta_Publisher(13),
        libvlc_meta_EncodedBy(14),
        libvlc_meta_ArtworkURL(15),
        libvlc_meta_TrackID(16),
        libvlc_meta_TrackTotal(17),
        libvlc_meta_Director(18),
        libvlc_meta_Season(19),
        libvlc_meta_Episode(20),
        libvlc_meta_ShowName(21),
        libvlc_meta_Actors(22),
        libvlc_meta_AlbumArtist(23),
        libvlc_meta_DiscNumber(24);
        libvlc_meta_t(long value) {
            this.value = value;
        }
        public final long value;
        public long value() {
            return this.value;
        }
        public Iterator<libvlc_meta_t > iterator() {
            return Collections.singleton(this).iterator();
        }
        public static IntValuedEnum<libvlc_meta_t > fromValue(int value) {
            return FlagSet.fromValue(value, values());
        }
    };
    /** enum values */
    public enum libvlc_state_t implements IntValuedEnum<libvlc_state_t > {
        libvlc_NothingSpecial(0),
        libvlc_Opening(1),
        libvlc_Buffering(2),
        libvlc_Playing(3),
        libvlc_Paused(4),
        libvlc_Stopped(5),
        libvlc_Ended(6),
        libvlc_Error(7);
        libvlc_state_t(long value) {
            this.value = value;
        }
        public final long value;
        public long value() {
            return this.value;
        }
        public Iterator<libvlc_state_t > iterator() {
            return Collections.singleton(this).iterator();
        }
        public static IntValuedEnum<libvlc_state_t > fromValue(int value) {
            return FlagSet.fromValue(value, values());
        }
    };
    public static final int libvlc_media_option_trusted = 0x2;
    public static final int libvlc_media_option_unique = 0x100;
    /** enum values */
    public enum libvlc_track_type_t implements IntValuedEnum<libvlc_track_type_t > {
        libvlc_track_unknown(-1),
        libvlc_track_audio(0),
        libvlc_track_video(1),
        libvlc_track_text(2);
        libvlc_track_type_t(long value) {
            this.value = value;
        }
        public final long value;
        public long value() {
            return this.value;
        }
        public Iterator<libvlc_track_type_t > iterator() {
            return Collections.singleton(this).iterator();
        }
        public static IntValuedEnum<libvlc_track_type_t > fromValue(int value) {
            return FlagSet.fromValue(value, values());
        }
    };
    /** enum values */
    public enum libvlc_media_type_t implements IntValuedEnum<libvlc_media_type_t > {
        libvlc_media_type_unknown(0),
        libvlc_media_type_file(1),
        libvlc_media_type_directory(2),
        libvlc_media_type_disc(3),
        libvlc_media_type_stream(4),
        libvlc_media_type_playlist(5);
        libvlc_media_type_t(long value) {
            this.value = value;
        }
        public final long value;
        public long value() {
            return this.value;
        }
        public Iterator<libvlc_media_type_t > iterator() {
            return Collections.singleton(this).iterator();
        }
        public static IntValuedEnum<libvlc_media_type_t > fromValue(int value) {
            return FlagSet.fromValue(value, values());
        }
    };
    /** enum values */
    public enum libvlc_media_parse_flag_t implements IntValuedEnum<libvlc_media_parse_flag_t > {
        libvlc_media_parse_local(0x00),
        libvlc_media_parse_network(0x01),
        libvlc_media_fetch_local(0x02),
        libvlc_media_fetch_network(0x04);
        libvlc_media_parse_flag_t(long value) {
            this.value = value;
        }
        public final long value;
        public long value() {
            return this.value;
        }
        public Iterator<libvlc_media_parse_flag_t > iterator() {
            return Collections.singleton(this).iterator();
        }
        public static IntValuedEnum<libvlc_media_parse_flag_t > fromValue(int value) {
            return FlagSet.fromValue(value, values());
        }
    };
    /** enum values */
    public enum libvlc_video_marquee_option_t implements IntValuedEnum<libvlc_video_marquee_option_t > {
        libvlc_marquee_Enable(0),
        /** string argument */
        libvlc_marquee_Text(1),
        libvlc_marquee_Color(2),
        libvlc_marquee_Opacity(3),
        libvlc_marquee_Position(4),
        libvlc_marquee_Refresh(5),
        libvlc_marquee_Size(6),
        libvlc_marquee_Timeout(7),
        libvlc_marquee_X(8),
        libvlc_marquee_Y(9);
        libvlc_video_marquee_option_t(long value) {
            this.value = value;
        }
        public final long value;
        public long value() {
            return this.value;
        }
        public Iterator<libvlc_video_marquee_option_t > iterator() {
            return Collections.singleton(this).iterator();
        }
        public static IntValuedEnum<libvlc_video_marquee_option_t > fromValue(int value) {
            return FlagSet.fromValue(value, values());
        }
    };
    /** enum values */
    public enum libvlc_navigate_mode_t implements IntValuedEnum<libvlc_navigate_mode_t > {
        libvlc_navigate_activate(0),
        libvlc_navigate_up(1),
        libvlc_navigate_down(2),
        libvlc_navigate_left(3),
        libvlc_navigate_right(4);
        libvlc_navigate_mode_t(long value) {
            this.value = value;
        }
        public final long value;
        public long value() {
            return this.value;
        }
        public Iterator<libvlc_navigate_mode_t > iterator() {
            return Collections.singleton(this).iterator();
        }
        public static IntValuedEnum<libvlc_navigate_mode_t > fromValue(int value) {
            return FlagSet.fromValue(value, values());
        }
    };
    /** enum values */
    public enum libvlc_position_t implements IntValuedEnum<libvlc_position_t > {
        libvlc_position_disable(-1),
        libvlc_position_center(0),
        libvlc_position_left(1),
        libvlc_position_right(2),
        libvlc_position_top(3),
        libvlc_position_top_left(4),
        libvlc_position_top_right(5),
        libvlc_position_bottom(6),
        libvlc_position_bottom_left(7),
        libvlc_position_bottom_right(8);
        libvlc_position_t(long value) {
            this.value = value;
        }
        public final long value;
        public long value() {
            return this.value;
        }
        public Iterator<libvlc_position_t > iterator() {
            return Collections.singleton(this).iterator();
        }
        public static IntValuedEnum<libvlc_position_t > fromValue(int value) {
            return FlagSet.fromValue(value, values());
        }
    };
    /**
     * option values for libvlc_video_{get,set}_logo_{int,string}<br>
     * enum values<br>
     * <i>native declaration : line 2796</i>
     */
    public enum libvlc_video_logo_option_t implements IntValuedEnum<libvlc_video_logo_option_t > {
        libvlc_logo_enable(0),
        /** < string argument, "file,d,t;file,d,t;..." */
        libvlc_logo_file(1),
        libvlc_logo_x(2),
        libvlc_logo_y(3),
        libvlc_logo_delay(4),
        libvlc_logo_repeat(5),
        libvlc_logo_opacity(6),
        libvlc_logo_position(7);
        libvlc_video_logo_option_t(long value) {
            this.value = value;
        }
        public final long value;
        public long value() {
            return this.value;
        }
        public Iterator<libvlc_video_logo_option_t > iterator() {
            return Collections.singleton(this).iterator();
        }
        public static IntValuedEnum<libvlc_video_logo_option_t > fromValue(int value) {
            return FlagSet.fromValue(value, values());
        }
    };
    /**
     * option values for libvlc_video_{get,set}_adjust_{int,float,bool}<br>
     * enum values<br>
     * <i>native declaration : line 2842</i>
     */
    public enum libvlc_video_adjust_option_t implements IntValuedEnum<libvlc_video_adjust_option_t > {
        libvlc_adjust_Enable(0),
        libvlc_adjust_Contrast(1),
        libvlc_adjust_Brightness(2),
        libvlc_adjust_Hue(3),
        libvlc_adjust_Saturation(4),
        libvlc_adjust_Gamma(5);
        libvlc_video_adjust_option_t(long value) {
            this.value = value;
        }
        public final long value;
        public long value() {
            return this.value;
        }
        public Iterator<libvlc_video_adjust_option_t > iterator() {
            return Collections.singleton(this).iterator();
        }
        public static IntValuedEnum<libvlc_video_adjust_option_t > fromValue(int value) {
            return FlagSet.fromValue(value, values());
        }
    };
    /** enum values */
    public enum libvlc_audio_output_device_types_t implements IntValuedEnum<libvlc_audio_output_device_types_t > {
        libvlc_AudioOutputDevice_Error(-1),
        libvlc_AudioOutputDevice_Mono(1),
        libvlc_AudioOutputDevice_Stereo(2),
        libvlc_AudioOutputDevice_2F2R(4),
        libvlc_AudioOutputDevice_3F2R(5),
        libvlc_AudioOutputDevice_5_1(6),
        libvlc_AudioOutputDevice_6_1(7),
        libvlc_AudioOutputDevice_7_1(8),
        libvlc_AudioOutputDevice_SPDIF(10);
        libvlc_audio_output_device_types_t(long value) {
            this.value = value;
        }
        public final long value;
        public long value() {
            return this.value;
        }
        public Iterator<libvlc_audio_output_device_types_t > iterator() {
            return Collections.singleton(this).iterator();
        }
        public static IntValuedEnum<libvlc_audio_output_device_types_t > fromValue(int value) {
            return FlagSet.fromValue(value, values());
        }
    };
    /** enum values */
    public enum libvlc_audio_output_channel_t implements IntValuedEnum<libvlc_audio_output_channel_t > {
        libvlc_AudioChannel_Error(-1),
        libvlc_AudioChannel_Stereo(1),
        libvlc_AudioChannel_RStereo(2),
        libvlc_AudioChannel_Left(3),
        libvlc_AudioChannel_Right(4),
        libvlc_AudioChannel_Dolbys(5);
        libvlc_audio_output_channel_t(long value) {
            this.value = value;
        }
        public final long value;
        public long value() {
            return this.value;
        }
        public Iterator<libvlc_audio_output_channel_t > iterator() {
            return Collections.singleton(this).iterator();
        }
        public static IntValuedEnum<libvlc_audio_output_channel_t > fromValue(int value) {
            return FlagSet.fromValue(value, values());
        }
    };
    /** enum values */
    public enum libvlc_playback_mode_t implements IntValuedEnum<libvlc_playback_mode_t > {
        libvlc_playback_mode_default(0),
        libvlc_playback_mode_loop(1),
        libvlc_playback_mode_repeat(2);
        libvlc_playback_mode_t(long value) {
            this.value = value;
        }
        public final long value;
        public long value() {
            return this.value;
        }
        public Iterator<libvlc_playback_mode_t > iterator() {
            return Collections.singleton(this).iterator();
        }
        public static IntValuedEnum<libvlc_playback_mode_t > fromValue(int value) {
            return FlagSet.fromValue(value, values());
        }
    };
    public static final int LIBVLC_STRUCTURES_H = (int)1;
    public static final int VLC_LIBVLC_H = (int)1;
    public static final int VLC_LIBVLC_MEDIA_H = (int)1;
    public static final int VLC_LIBVLC_MEDIA_PLAYER_H = (int)1;
    public static final int LIBVLC_MEDIA_LIST_H = (int)1;
    public static final int LIBVLC_MEDIA_LIST_PLAYER_H = (int)1;
    public static final int VLC_LIBVLC_MEDIA_LIBRARY_H = (int)1;
    public static final int VLC_LIBVLC_MEDIA_DISCOVERER_H = (int)1;
    public static abstract class libvlc_callback_t extends Callback<libvlc_callback_t > {
        public abstract void apply(Pointer<LibvlcLibrary.libvlc_event_t > libvlc_event_tPtr1, Pointer<? > voidPtr1);
    };
    public static abstract class libvlc_log_cb extends Callback<libvlc_log_cb > {
        public abstract void apply(Pointer<? > data, int level, Pointer<LibvlcLibrary.vlc_log_t > ctx, Pointer<Byte > fmt, Object... args);
    };
    /** <i>native declaration : line 260</i> */
    public static abstract class libvlc_set_exit_handler_cb_callback extends Callback<libvlc_set_exit_handler_cb_callback > {
        public abstract void apply(Pointer<? > voidPtr1);
    };
    public static abstract class libvlc_media_open_cb extends Callback<libvlc_media_open_cb > {
        public abstract int apply(Pointer<? > opaque, Pointer<Pointer<? > > datap, Pointer<Long > sizep);
    };
    /**
     * Callback prototype to read data from a custom bitstream input media.<br>
     * * \param opaque private pointer as set by the @ref libvlc_media_open_cb<br>
     *               callback<br>
     * \param buf start address of the buffer to read data into<br>
     * \param len bytes length of the buffer<br>
     * * \return strictly positive number of bytes read, 0 on end-of-stream,<br>
     *         or -1 on non-recoverable error<br>
     * * \note If no data is immediately available, then the callback should sleep.<br>
     * \warning The application is responsible for avoiding deadlock situations.<br>
     * In particular, the callback should return an error if playback is stopped;<br>
     * if it does not return, then libvlc_media_player_stop() will never return.<br>
     * <i>native declaration : line 1012</i>
     */
    public static abstract class ssize_t extends Callback<ssize_t > {
        public abstract LibvlcLibrary.ssize_t_callback apply(Pointer<? > libvlc_media_read_cb);
    };
    public static abstract class libvlc_media_seek_cb extends Callback<libvlc_media_seek_cb > {
        public abstract int apply(Pointer<? > opaque, long offset);
    };
    public static abstract class libvlc_media_close_cb extends Callback<libvlc_media_close_cb > {
        public abstract void apply(Pointer<? > opaque);
    };
    public static abstract class ssize_t_callback extends Callback<ssize_t_callback > {
        public abstract int apply(Pointer<? > opaque, Pointer<Byte > buf, @Ptr long len);
    };
    public static abstract class libvlc_video_lock_cb extends Callback<libvlc_video_lock_cb > {
        public abstract Pointer<? > apply(Pointer<? > opaque, Pointer<Pointer<? > > planes);
    };
    public static abstract class libvlc_video_unlock_cb extends Callback<libvlc_video_unlock_cb > {
        public abstract void apply(Pointer<? > opaque, Pointer<? > picture, Pointer<Pointer<? > > planes);
    };
    public static abstract class libvlc_video_display_cb extends Callback<libvlc_video_display_cb > {
        public abstract void apply(Pointer<? > opaque, Pointer<? > picture);
    };
    public static abstract class libvlc_video_format_cb extends Callback<libvlc_video_format_cb > {
        public abstract int apply(Pointer<Pointer<? > > opaque, Pointer<Byte > chroma, Pointer<Integer > width, Pointer<Integer > height, Pointer<Integer > pitches, Pointer<Integer > lines);
    };
    public static abstract class libvlc_video_cleanup_cb extends Callback<libvlc_video_cleanup_cb > {
        public abstract void apply(Pointer<? > opaque);
    };
    public static abstract class libvlc_audio_play_cb extends Callback<libvlc_audio_play_cb > {
        public abstract void apply(Pointer<? > data, Pointer<? > samples, int count, long pts);
    };
    public static abstract class libvlc_audio_pause_cb extends Callback<libvlc_audio_pause_cb > {
        public abstract void apply(Pointer<? > data, long pts);
    };
    public static abstract class libvlc_audio_resume_cb extends Callback<libvlc_audio_resume_cb > {
        public abstract void apply(Pointer<? > data, long pts);
    };
    public static abstract class libvlc_audio_flush_cb extends Callback<libvlc_audio_flush_cb > {
        public abstract void apply(Pointer<? > data, long pts);
    };
    public static abstract class libvlc_audio_drain_cb extends Callback<libvlc_audio_drain_cb > {
        public abstract void apply(Pointer<? > data);
    };
    public static abstract class libvlc_audio_set_volume_cb extends Callback<libvlc_audio_set_volume_cb > {
        public abstract void apply(Pointer<? > data, float volume, boolean mute);
    };
    public static abstract class libvlc_audio_setup_cb extends Callback<libvlc_audio_setup_cb > {
        public abstract int apply(Pointer<Pointer<? > > data, Pointer<Byte > format, Pointer<Integer > rate, Pointer<Integer > channels);
    };
    public static abstract class libvlc_audio_cleanup_cb extends Callback<libvlc_audio_cleanup_cb > {
        public abstract void apply(Pointer<? > data);
    };
    /**
     * A human-readable error message for the last LibVLC error in the calling<br>
     * thread. The resulting string is valid until another error occurs (at least<br>
     * until the next LibVLC call).<br>
     * @warning<br>
     * This will be NULL if there was no error.<br>
     * Original signature : <code>char* libvlc_errmsg()</code><br>
     * <i>native declaration : line 161</i>
     */
    public static native Pointer<Byte > libvlc_errmsg();
    /**
     * Clears the LibVLC error status for the current thread. This is optional.<br>
     * By default, the error status is automatically overridden when a new error<br>
     * occurs, and destroyed when the thread exits.<br>
     * Original signature : <code>void libvlc_clearerr()</code><br>
     * <i>native declaration : line 168</i>
     */
    public static native void libvlc_clearerr();
    /**
     * Sets the LibVLC error status and message for the current thread.<br>
     * Any previous error is overridden.<br>
     * \param fmt the format string<br>
     * \param ap the arguments<br>
     * \return a nul terminated string in any case<br>
     * Original signature : <code>char* libvlc_vprinterr(const char*, va_list)</code><br>
     * <i>native declaration : line 177</i>
     */
    public static native Pointer<Byte > libvlc_vprinterr(Pointer<Byte > fmt, Object... ap);
    /**
     * Sets the LibVLC error status and message for the current thread.<br>
     * Any previous error is overridden.<br>
     * \param fmt the format string<br>
     * \param args the arguments<br>
     * \return a nul terminated string in any case<br>
     * Original signature : <code>char* libvlc_printerr(const char*, null)</code><br>
     * <i>native declaration : line 186</i>
     */
    public static native Pointer<Byte > libvlc_printerr(Pointer<Byte > fmt, Object... varArgs1);
    /**
     * Create and initialize a libvlc instance.<br>
     * This functions accept a list of "command line" arguments similar to the<br>
     * main(). These arguments affect the LibVLC instance default configuration.<br>
     * \version<br>
     * Arguments are meant to be passed from the command line to LibVLC, just like<br>
     * VLC media player does. The list of valid arguments depends on the LibVLC<br>
     * version, the operating system and platform, and set of available LibVLC<br>
     * plugins. Invalid or unsupported arguments will cause the function to fail<br>
     * (i.e. return NULL). Also, some arguments may alter the behaviour or<br>
     * otherwise interfere with other LibVLC functions.<br>
     * \warning<br>
     * There is absolutely no warranty or promise of forward, backward and<br>
     * cross-platform compatibility with regards to libvlc_new() arguments.<br>
     * We recommend that you do not use them, other than when debugging.<br>
     * \param argc the number of arguments (should be 0)<br>
     * \param argv list of arguments (should be NULL)<br>
     * \return the libvlc instance or NULL in case of error<br>
     * Original signature : <code>libvlc_instance_t* libvlc_new(int, const const char**)</code><br>
     * <i>native declaration : line 212</i>
     */
    public static native Pointer<LibvlcLibrary.libvlc_instance_t > libvlc_new(int argc, Pointer<Pointer<Byte > > argv);
    /**
     * Decrement the reference count of a libvlc instance, and destroy it<br>
     * if it reaches zero.<br>
     * \param p_instance the instance to destroy<br>
     * Original signature : <code>void libvlc_release(libvlc_instance_t*)</code><br>
     * <i>native declaration : line 221</i>
     */
    public static native void libvlc_release(Pointer<LibvlcLibrary.libvlc_instance_t > p_instance);
    /**
     * Increments the reference count of a libvlc instance.<br>
     * The initial reference count is 1 after libvlc_new() returns.<br>
     * \param p_instance the instance to reference<br>
     * Original signature : <code>void libvlc_retain(libvlc_instance_t*)</code><br>
     * <i>native declaration : line 229</i>
     */
    public static native void libvlc_retain(Pointer<LibvlcLibrary.libvlc_instance_t > p_instance);
    /**
     * Try to start a user interface for the libvlc instance.<br>
     * \param p_instance the instance<br>
     * \param name interface name, or NULL for default<br>
     * \return 0 on success, -1 on error.<br>
     * Original signature : <code>int libvlc_add_intf(libvlc_instance_t*, const char*)</code><br>
     * <i>native declaration : line 239</i>
     */
    public static native int libvlc_add_intf(Pointer<LibvlcLibrary.libvlc_instance_t > p_instance, Pointer<Byte > name);
    /**
     * Registers a callback for the LibVLC exit event. This is mostly useful if<br>
     * the VLC playlist and/or at least one interface are started with<br>
     * libvlc_playlist_play() or libvlc_add_intf() respectively.<br>
     * Typically, this function will wake up your application main loop (from<br>
     * another thread).<br>
     * \note This function should be called before the playlist or interface are<br>
     * started. Otherwise, there is a small race condition: the exit event could<br>
     * be raised before the handler is registered.<br>
     * \param p_instance LibVLC instance<br>
     * \param cb callback to invoke when LibVLC wants to exit,<br>
     *           or NULL to disable the exit handler (as by default)<br>
     * \param opaque data pointer for the callback<br>
     * \warning This function and libvlc_wait() cannot be used at the same time.<br>
     * Original signature : <code>void libvlc_set_exit_handler(libvlc_instance_t*, libvlc_set_exit_handler_cb_callback*, void*)</code><br>
     * <i>native declaration : line 259</i>
     */
    public static native void libvlc_set_exit_handler(Pointer<LibvlcLibrary.libvlc_instance_t > p_instance, Pointer<LibvlcLibrary.libvlc_set_exit_handler_cb_callback > cb, Pointer<? > opaque);
    /**
     * Waits until an interface causes the instance to exit.<br>
     * You should start at least one interface first, using libvlc_add_intf().<br>
     * \param p_instance the instance<br>
     * \warning This function wastes one thread doing basically nothing.<br>
     * libvlc_set_exit_handler() should be used instead.<br>
     * Original signature : <code>void libvlc_wait(libvlc_instance_t*)</code><br>
     * <i>native declaration : line 271</i>
     */
    public static native void libvlc_wait(Pointer<LibvlcLibrary.libvlc_instance_t > p_instance);
    /**
     * Sets the application name. LibVLC passes this as the user agent string<br>
     * when a protocol requires it.<br>
     * \param p_instance LibVLC instance<br>
     * \param name human-readable application name, e.g. "FooBar player 1.2.3"<br>
     * \param http HTTP User Agent, e.g. "FooBar/1.2.3 Python/2.6.0"<br>
     * \version LibVLC 1.1.1 or later<br>
     * Original signature : <code>void libvlc_set_user_agent(libvlc_instance_t*, const char*, const char*)</code><br>
     * <i>native declaration : line 283</i>
     */
    public static native void libvlc_set_user_agent(Pointer<LibvlcLibrary.libvlc_instance_t > p_instance, Pointer<Byte > name, Pointer<Byte > http);
    /**
     * Sets some meta-information about the application.<br>
     * See also libvlc_set_user_agent().<br>
     * \param p_instance LibVLC instance<br>
     * \param id Java-style application identifier, e.g. "com.acme.foobar"<br>
     * \param version application version numbers, e.g. "1.2.3"<br>
     * \param icon application icon name, e.g. "foobar"<br>
     * \version LibVLC 2.1.0 or later.<br>
     * Original signature : <code>void libvlc_set_app_id(libvlc_instance_t*, const char*, const char*, const char*)</code><br>
     * <i>native declaration : line 297</i>
     */
    public static native void libvlc_set_app_id(Pointer<LibvlcLibrary.libvlc_instance_t > p_instance, Pointer<Byte > id, Pointer<Byte > version, Pointer<Byte > icon);
    /**
     * Retrieve libvlc version.<br>
     * Example: "1.1.0-git The Luggage"<br>
     * \return a string containing the libvlc version<br>
     * Original signature : <code>char* libvlc_get_version()</code><br>
     * <i>native declaration : line 307</i>
     */
    public static native Pointer<Byte > libvlc_get_version();
    /**
     * Retrieve libvlc compiler version.<br>
     * Example: "gcc version 4.2.3 (Ubuntu 4.2.3-2ubuntu6)"<br>
     * \return a string containing the libvlc compiler version<br>
     * Original signature : <code>char* libvlc_get_compiler()</code><br>
     * <i>native declaration : line 316</i>
     */
    public static native Pointer<Byte > libvlc_get_compiler();
    /**
     * Retrieve libvlc changeset.<br>
     * Example: "aa9bce0bc4"<br>
     * \return a string containing the libvlc changeset<br>
     * Original signature : <code>char* libvlc_get_changeset()</code><br>
     * <i>native declaration : line 325</i>
     */
    public static native Pointer<Byte > libvlc_get_changeset();
    /**
     * Frees an heap allocation returned by a LibVLC function.<br>
     * If you know you're using the same underlying C run-time as the LibVLC<br>
     * implementation, then you can call ANSI C free() directly instead.<br>
     * \param ptr the pointer<br>
     * Original signature : <code>void libvlc_free(void*)</code><br>
     * <i>native declaration : line 334</i>
     */
    public static native void libvlc_free(Pointer<? > ptr);
    /**
     * Register for an event notification.<br>
     * \param p_event_manager the event manager to which you want to attach to.<br>
     *        Generally it is obtained by vlc_my_object_event_manager() where<br>
     *        my_object is the object you want to listen to.<br>
     * \param i_event_type the desired event to which we want to listen<br>
     * \param f_callback the function to call when i_event_type occurs<br>
     * \param user_data user provided data to carry with the event<br>
     * \return 0 on success, ENOMEM on error<br>
     * Original signature : <code>int libvlc_event_attach(libvlc_event_manager_t*, libvlc_event_type_t, libvlc_callback_t, void*)</code><br>
     * <i>native declaration : line 377</i>
     */
    public static native int libvlc_event_attach(Pointer<LibvlcLibrary.libvlc_event_manager_t > p_event_manager, int i_event_type, Pointer<LibvlcLibrary.libvlc_callback_t > f_callback, Pointer<? > user_data);
    /**
     * Unregister an event notification.<br>
     * \param p_event_manager the event manager<br>
     * \param i_event_type the desired event to which we want to unregister<br>
     * \param f_callback the function to call when i_event_type occurs<br>
     * \param p_user_data user provided data to carry with the event<br>
     * Original signature : <code>void libvlc_event_detach(libvlc_event_manager_t*, libvlc_event_type_t, libvlc_callback_t, void*)</code><br>
     * <i>native declaration : line 390</i>
     */
    public static native void libvlc_event_detach(Pointer<LibvlcLibrary.libvlc_event_manager_t > p_event_manager, int i_event_type, Pointer<LibvlcLibrary.libvlc_callback_t > f_callback, Pointer<? > p_user_data);
    /**
     * Get an event's type name.<br>
     * \param event_type the desired event<br>
     * Original signature : <code>char* libvlc_event_type_name(libvlc_event_type_t)</code><br>
     * <i>native declaration : line 400</i>
     */
    public static native Pointer<Byte > libvlc_event_type_name(int event_type);
    /**
     * Gets debugging information about a log message: the name of the VLC module<br>
     * emitting the message and the message location within the source code.<br>
     * The returned module name and file name will be NULL if unknown.<br>
     * The returned line number will similarly be zero if unknown.<br>
     * \param ctx message context (as passed to the @ref libvlc_log_cb callback)<br>
     * \param module module name storage (or NULL) [OUT]<br>
     * \param file source code file name storage (or NULL) [OUT]<br>
     * \param line source code file line number storage (or NULL) [OUT]<br>
     * \warning The returned module name and source code file name, if non-NULL,<br>
     * are only valid until the logging callback returns.<br>
     * \version LibVLC 2.1.0 or later<br>
     * Original signature : <code>void libvlc_log_get_context(const libvlc_log_t*, const char**, const char**, unsigned*)</code><br>
     * <i>native declaration : line 440</i>
     */
    public static native void libvlc_log_get_context(Pointer<LibvlcLibrary.vlc_log_t > ctx, Pointer<Pointer<Byte > > module, Pointer<Pointer<Byte > > file, Pointer<Integer > line);
    /**
     * Gets VLC object information about a log message: the type name of the VLC<br>
     * object emitting the message, the object header if any and a temporaly-unique<br>
     * object identifier. This information is mainly meant for <b>manual</b><br>
     * troubleshooting.<br>
     * The returned type name may be "generic" if unknown, but it cannot be NULL.<br>
     * The returned header will be NULL if unset; in current versions, the header<br>
     * is used to distinguish for VLM inputs.<br>
     * The returned object ID will be zero if the message is not associated with<br>
     * any VLC object.<br>
     * \param ctx message context (as passed to the @ref libvlc_log_cb callback)<br>
     * \param name object name storage (or NULL) [OUT]<br>
     * \param header object header (or NULL) [OUT]<br>
     * \param line source code file line number storage (or NULL) [OUT]<br>
     * \warning The returned module name and source code file name, if non-NULL,<br>
     * are only valid until the logging callback returns.<br>
     * \version LibVLC 2.1.0 or later<br>
     * Original signature : <code>void libvlc_log_get_object(const libvlc_log_t*, const char**, const char**, uintptr_t*)</code><br>
     * <i>native declaration : line 464</i>
     */
    public static native void libvlc_log_get_object(Pointer<LibvlcLibrary.vlc_log_t > ctx, Pointer<Pointer<Byte > > name, Pointer<Pointer<Byte > > header, Pointer<Pointer<Integer > > id);
    /**
     * Unsets the logging callback for a LibVLC instance. This is rarely needed:<br>
     * the callback is implicitly unset when the instance is destroyed.<br>
     * This function will wait for any pending callbacks invocation to complete<br>
     * (causing a deadlock if called from within the callback).<br>
     * \param p_instance libvlc instance<br>
     * \version LibVLC 2.1.0 or later<br>
     * Original signature : <code>void libvlc_log_unset(libvlc_instance_t*)</code><br>
     * <i>native declaration : line 490</i>
     */
    public static native void libvlc_log_unset(Pointer<LibvlcLibrary.libvlc_instance_t > libvlc_instance_tPtr1);
    /**
     * Sets the logging callback for a LibVLC instance.<br>
     * This function is thread-safe: it will wait for any pending callbacks<br>
     * invocation to complete.<br>
     * \param cb callback function pointer<br>
     * \param data opaque data pointer for the callback function<br>
     * \note Some log messages (especially debug) are emitted by LibVLC while<br>
     * is being initialized. These messages cannot be captured with this interface.<br>
     * \warning A deadlock may occur if this function is called from the callback.<br>
     * \param p_instance libvlc instance<br>
     * \version LibVLC 2.1.0 or later<br>
     * Original signature : <code>void libvlc_log_set(libvlc_instance_t*, libvlc_log_cb, void*)</code><br>
     * <i>native declaration : line 508</i>
     */
    public static native void libvlc_log_set(Pointer<LibvlcLibrary.libvlc_instance_t > libvlc_instance_tPtr1, Pointer<LibvlcLibrary.libvlc_log_cb > cb, Pointer<? > data);
    /**
     * Sets up logging to a file.<br>
     * \param p_instance libvlc instance<br>
     * \param stream FILE pointer opened for writing<br>
     *         (the FILE pointer must remain valid until libvlc_log_unset())<br>
     * \version LibVLC 2.1.0 or later<br>
     * Original signature : <code>void libvlc_log_set_file(libvlc_instance_t*, FILE*)</code><br>
     * <i>native declaration : line 519</i>
     */
    public static native void libvlc_log_set_file(Pointer<LibvlcLibrary.libvlc_instance_t > libvlc_instance_tPtr1, Pointer<LibvlcLibrary.FILE > stream);
    /**
     * Always returns minus one.<br>
     * This function is only provided for backward compatibility.<br>
     * \param p_instance ignored<br>
     * \return always -1<br>
     * Original signature : <code>int libvlc_get_log_verbosity(const libvlc_instance_t*)</code><br>
     * <i>native declaration : line 529</i>
     */
    public static native int libvlc_get_log_verbosity(Pointer<LibvlcLibrary.libvlc_instance_t > p_instance);
    /**
     * This function does nothing.<br>
     * It is only provided for backward compatibility.<br>
     * \param p_instance ignored<br>
     * \param level ignored<br>
     * Original signature : <code>void libvlc_set_log_verbosity(libvlc_instance_t*, unsigned)</code><br>
     * <i>native declaration : line 539</i>
     */
    public static native void libvlc_set_log_verbosity(Pointer<LibvlcLibrary.libvlc_instance_t > p_instance, int level);
    /**
     * This function does nothing useful.<br>
     * It is only provided for backward compatibility.<br>
     * \param p_instance libvlc instance<br>
     * \return an unique pointer or NULL on error<br>
     * Original signature : <code>libvlc_log_t* libvlc_log_open(libvlc_instance_t*)</code><br>
     * <i>native declaration : line 549</i>
     */
    public static native Pointer<LibvlcLibrary.vlc_log_t > libvlc_log_open(Pointer<LibvlcLibrary.libvlc_instance_t > p_instance);
    /**
     * Frees memory allocated by libvlc_log_open().<br>
     * \param p_log libvlc log instance or NULL<br>
     * Original signature : <code>void libvlc_log_close(libvlc_log_t*)</code><br>
     * <i>native declaration : line 557</i>
     */
    public static native void libvlc_log_close(Pointer<LibvlcLibrary.vlc_log_t > p_log);
    /**
     * Always returns zero.<br>
     * This function is only provided for backward compatibility.<br>
     * \param p_log ignored<br>
     * \return always zero<br>
     * Original signature : <code>int libvlc_log_count(const libvlc_log_t*)</code><br>
     * <i>native declaration : line 567</i>
     */
    public static native int libvlc_log_count(Pointer<LibvlcLibrary.vlc_log_t > p_log);
    /**
     * This function does nothing.<br>
     * It is only provided for backward compatibility.<br>
     * \param p_log ignored<br>
     * Original signature : <code>void libvlc_log_clear(libvlc_log_t*)</code><br>
     * <i>native declaration : line 576</i>
     */
    public static native void libvlc_log_clear(Pointer<LibvlcLibrary.vlc_log_t > p_log);
    /**
     * This function does nothing useful.<br>
     * It is only provided for backward compatibility.<br>
     * \param p_log ignored<br>
     * \return an unique pointer or NULL on error or if the parameter was NULL<br>
     * Original signature : <code>libvlc_log_iterator_t* libvlc_log_get_iterator(const libvlc_log_t*)</code><br>
     * <i>native declaration : line 586</i>
     */
    public static native Pointer<LibvlcLibrary.libvlc_log_iterator_t > libvlc_log_get_iterator(Pointer<LibvlcLibrary.vlc_log_t > p_log);
    /**
     * Frees memory allocated by libvlc_log_get_iterator().<br>
     * \param p_iter libvlc log iterator or NULL<br>
     * Original signature : <code>void libvlc_log_iterator_free(libvlc_log_iterator_t*)</code><br>
     * <i>native declaration : line 594</i>
     */
    public static native void libvlc_log_iterator_free(Pointer<LibvlcLibrary.libvlc_log_iterator_t > p_iter);
    /**
     * Always returns zero.<br>
     * This function is only provided for backward compatibility.<br>
     * \param p_iter ignored<br>
     * \return always zero<br>
     * Original signature : <code>int libvlc_log_iterator_has_next(const libvlc_log_iterator_t*)</code><br>
     * <i>native declaration : line 604</i>
     */
    public static native int libvlc_log_iterator_has_next(Pointer<LibvlcLibrary.libvlc_log_iterator_t > p_iter);
    /**
     * Always returns NULL.<br>
     * This function is only provided for backward compatibility.<br>
     * \param p_iter libvlc log iterator or NULL<br>
     * \param p_buf ignored<br>
     * \return always NULL<br>
     * Original signature : <code>libvlc_log_message_t* libvlc_log_iterator_next(libvlc_log_iterator_t*, libvlc_log_message_t*)</code><br>
     * <i>native declaration : line 615</i>
     */
    public static native Pointer<libvlc_log_message_t > libvlc_log_iterator_next(Pointer<LibvlcLibrary.libvlc_log_iterator_t > p_iter, Pointer<libvlc_log_message_t > p_buf);
    /**
     * Release a list of module descriptions.<br>
     * \param p_list the list to be released<br>
     * Original signature : <code>void libvlc_module_description_list_release(libvlc_module_description_t*)</code><br>
     * <i>native declaration : line 638</i>
     */
    public static native void libvlc_module_description_list_release(Pointer<libvlc_module_description_t > p_list);
    /**
     * Returns a list of audio filters that are available.<br>
     * \param p_instance libvlc instance<br>
     * \return a list of module descriptions. It should be freed with libvlc_module_description_list_release().<br>
     *         In case of an error, NULL is returned.<br>
     * \see libvlc_module_description_t<br>
     * \see libvlc_module_description_list_release<br>
     * Original signature : <code>libvlc_module_description_t* libvlc_audio_filter_list_get(libvlc_instance_t*)</code><br>
     * <i>native declaration : line 652</i>
     */
    public static native Pointer<libvlc_module_description_t > libvlc_audio_filter_list_get(Pointer<LibvlcLibrary.libvlc_instance_t > p_instance);
    /**
     * Returns a list of video filters that are available.<br>
     * \param p_instance libvlc instance<br>
     * \return a list of module descriptions. It should be freed with libvlc_module_description_list_release().<br>
     *         In case of an error, NULL is returned.<br>
     * \see libvlc_module_description_t<br>
     * \see libvlc_module_description_list_release<br>
     * Original signature : <code>libvlc_module_description_t* libvlc_video_filter_list_get(libvlc_instance_t*)</code><br>
     * <i>native declaration : line 666</i>
     */
    public static native Pointer<libvlc_module_description_t > libvlc_video_filter_list_get(Pointer<LibvlcLibrary.libvlc_instance_t > p_instance);
    /**
     * Return the current time as defined by LibVLC. The unit is the microsecond.<br>
     * Time increases monotonically (regardless of time zone changes and RTC<br>
     * adjustements).<br>
     * The origin is arbitrary but consistent across the whole system<br>
     * (e.g. the system uptim, the time since the system was booted).<br>
     * \note On systems that support it, the POSIX monotonic clock is used.<br>
     * Original signature : <code>int64_t libvlc_clock()</code><br>
     * <i>native declaration : line 684</i>
     */
    public static native long libvlc_clock();
    /**
     * Return the delay (in microseconds) until a certain timestamp.<br>
     * \param pts timestamp<br>
     * \return negative if timestamp is in the past,<br>
     * positive if it is in the future<br>
     * Original signature : <code>int64_t libvlc_delay(int64_t)</code><br>
     * <i>native declaration : line 692</i>
     */
    public static native long libvlc_delay(long pts);
    /**
     * Create a media with a certain given media resource location,<br>
     * for instance a valid URL.<br>
     * \note To refer to a local file with this function,<br>
     * the file://... URI syntax <b>must</b> be used (see IETF RFC3986).<br>
     * We recommend using libvlc_media_new_path() instead when dealing with<br>
     * local files.<br>
     * \see libvlc_media_release<br>
     * \param p_instance the instance<br>
     * \param psz_mrl the media location<br>
     * \return the newly created media or NULL on error<br>
     * Original signature : <code>libvlc_media_t* libvlc_media_new_location(libvlc_instance_t*, const char*)</code><br>
     * <i>native declaration : line 1048</i>
     */
    public static native Pointer<LibvlcLibrary.libvlc_media_t > libvlc_media_new_location(Pointer<LibvlcLibrary.libvlc_instance_t > p_instance, Pointer<Byte > psz_mrl);
    /**
     * Create a media for a certain file path.<br>
     * \see libvlc_media_release<br>
     * \param p_instance the instance<br>
     * \param path local filesystem path<br>
     * \return the newly created media or NULL on error<br>
     * Original signature : <code>libvlc_media_t* libvlc_media_new_path(libvlc_instance_t*, const char*)</code><br>
     * <i>native declaration : line 1061</i>
     */
    public static native Pointer<LibvlcLibrary.libvlc_media_t > libvlc_media_new_path(Pointer<LibvlcLibrary.libvlc_instance_t > p_instance, Pointer<Byte > path);
    /**
     * Create a media for an already open file descriptor.<br>
     * The file descriptor shall be open for reading (or reading and writing).<br>
     * Regular file descriptors, pipe read descriptors and character device<br>
     * descriptors (including TTYs) are supported on all platforms.<br>
     * Block device descriptors are supported where available.<br>
     * Directory descriptors are supported on systems that provide fdopendir().<br>
     * Sockets are supported on all platforms where they are file descriptors,<br>
     * i.e. all except Windows.<br>
     * \note This library will <b>not</b> automatically close the file descriptor<br>
     * under any circumstance. Nevertheless, a file descriptor can usually only be<br>
     * rendered once in a media player. To render it a second time, the file<br>
     * descriptor should probably be rewound to the beginning with lseek().<br>
     * \see libvlc_media_release<br>
     * \version LibVLC 1.1.5 and later.<br>
     * \param p_instance the instance<br>
     * \param fd open file descriptor<br>
     * \return the newly created media or NULL on error<br>
     * Original signature : <code>libvlc_media_t* libvlc_media_new_fd(libvlc_instance_t*, int)</code><br>
     * <i>native declaration : line 1089</i>
     */
    public static native Pointer<LibvlcLibrary.libvlc_media_t > libvlc_media_new_fd(Pointer<LibvlcLibrary.libvlc_instance_t > p_instance, int fd);
    /**
     * Create a media with custom callbacks to read the data from.<br>
     * \param instance LibVLC instance<br>
     * \param open_cb callback to open the custom bitstream input media<br>
     * \param read_cb callback to read data (must not be NULL)<br>
     * \param seek_cb callback to seek, or NULL if seeking is not supported<br>
     * \param close_cb callback to close the media, or NULL if unnecessary<br>
     * \param opaque data pointer for the open callback<br>
     * \return the newly created media or NULL on error<br>
     * \note If open_cb is NULL, the opaque pointer will be passed to read_cb,<br>
     * seek_cb and close_cb, and the stream size will be treated as unknown.<br>
     * \note The callbacks may be called asynchronously (from another thread).<br>
     * A single stream instance need not be reentrant. However the open_cb needs to<br>
     * be reentrant if the media is used by multiple player instances.<br>
     * \warning The callbacks may be used until all or any player instances<br>
     * that were supplied the media item are stopped.<br>
     * \see libvlc_media_release<br>
     * \version LibVLC 3.0.0 and later.<br>
     * Original signature : <code>libvlc_media_t* libvlc_media_new_callbacks(libvlc_instance_t*, libvlc_media_open_cb, libvlc_media_read_cb, libvlc_media_seek_cb, libvlc_media_close_cb, void*)</code><br>
     * <i>native declaration : line 1119</i>
     */
    public static native Pointer<LibvlcLibrary.libvlc_media_t > libvlc_media_new_callbacks(Pointer<LibvlcLibrary.libvlc_instance_t > instance, Pointer<LibvlcLibrary.libvlc_media_open_cb > open_cb, LibvlcLibrary.libvlc_media_read_cb read_cb, Pointer<LibvlcLibrary.libvlc_media_seek_cb > seek_cb, Pointer<LibvlcLibrary.libvlc_media_close_cb > close_cb, Pointer<? > opaque);
    /**
     * Create a media as an empty node with a given name.<br>
     * \see libvlc_media_release<br>
     * \param p_instance the instance<br>
     * \param psz_name the name of the node<br>
     * \return the new empty media or NULL on error<br>
     * Original signature : <code>libvlc_media_t* libvlc_media_new_as_node(libvlc_instance_t*, const char*)</code><br>
     * <i>native declaration : line 1136</i>
     */
    public static native Pointer<LibvlcLibrary.libvlc_media_t > libvlc_media_new_as_node(Pointer<LibvlcLibrary.libvlc_instance_t > p_instance, Pointer<Byte > psz_name);
    /**
     * Add an option to the media.<br>
     * This option will be used to determine how the media_player will<br>
     * read the media. This allows to use VLC's advanced<br>
     * reading/streaming options on a per-media basis.<br>
     * \note The options are listed in 'vlc --long-help' from the command line,<br>
     * e.g. "-sout-all". Keep in mind that available options and their semantics<br>
     * vary across LibVLC versions and builds.<br>
     * \warning Not all options affects libvlc_media_t objects:<br>
     * Specifically, due to architectural issues most audio and video options,<br>
     * such as text renderer options, have no effects on an individual media.<br>
     * These options must be set through libvlc_new() instead.<br>
     * \param p_md the media descriptor<br>
     * \param psz_options the options (as a string)<br>
     * Original signature : <code>void libvlc_media_add_option(libvlc_media_t*, const char*)</code><br>
     * <i>native declaration : line 1158</i>
     */
    public static native void libvlc_media_add_option(Pointer<LibvlcLibrary.libvlc_media_t > p_md, Pointer<Byte > psz_options);
    /**
     * Add an option to the media with configurable flags.<br>
     * This option will be used to determine how the media_player will<br>
     * read the media. This allows to use VLC's advanced<br>
     * reading/streaming options on a per-media basis.<br>
     * The options are detailed in vlc --long-help, for instance<br>
     * "--sout-all". Note that all options are not usable on medias:<br>
     * specifically, due to architectural issues, video-related options<br>
     * such as text renderer options cannot be set on a single media. They<br>
     * must be set on the whole libvlc instance instead.<br>
     * \param p_md the media descriptor<br>
     * \param psz_options the options (as a string)<br>
     * \param i_flags the flags for this option<br>
     * Original signature : <code>void libvlc_media_add_option_flag(libvlc_media_t*, const char*, unsigned)</code><br>
     * <i>native declaration : line 1179</i>
     */
    public static native void libvlc_media_add_option_flag(Pointer<LibvlcLibrary.libvlc_media_t > p_md, Pointer<Byte > psz_options, int i_flags);
    /**
     * Retain a reference to a media descriptor object (libvlc_media_t). Use<br>
     * libvlc_media_release() to decrement the reference count of a<br>
     * media descriptor object.<br>
     * \param p_md the media descriptor<br>
     * Original signature : <code>void libvlc_media_retain(libvlc_media_t*)</code><br>
     * <i>native declaration : line 1192</i>
     */
    public static native void libvlc_media_retain(Pointer<LibvlcLibrary.libvlc_media_t > p_md);
    /**
     * Decrement the reference count of a media descriptor object. If the<br>
     * reference count is 0, then libvlc_media_release() will release the<br>
     * media descriptor object. It will send out an libvlc_MediaFreed event<br>
     * to all listeners. If the media descriptor object has been released it<br>
     * should not be used again.<br>
     * \param p_md the media descriptor<br>
     * Original signature : <code>void libvlc_media_release(libvlc_media_t*)</code><br>
     * <i>native declaration : line 1203</i>
     */
    public static native void libvlc_media_release(Pointer<LibvlcLibrary.libvlc_media_t > p_md);
    /**
     * Get the media resource locator (mrl) from a media descriptor object<br>
     * \param p_md a media descriptor object<br>
     * \return string with mrl of media descriptor object<br>
     * Original signature : <code>char* libvlc_media_get_mrl(libvlc_media_t*)</code><br>
     * <i>native declaration : line 1212</i>
     */
    public static native Pointer<Byte > libvlc_media_get_mrl(Pointer<LibvlcLibrary.libvlc_media_t > p_md);
    /**
     * Duplicate a media descriptor object.<br>
     * \param p_md a media descriptor object.<br>
     * Original signature : <code>libvlc_media_t* libvlc_media_duplicate(libvlc_media_t*)</code><br>
     * <i>native declaration : line 1219</i>
     */
    public static native Pointer<LibvlcLibrary.libvlc_media_t > libvlc_media_duplicate(Pointer<LibvlcLibrary.libvlc_media_t > p_md);
    /**
     * Read the meta of the media.<br>
     * If the media has not yet been parsed this will return NULL.<br>
     * This methods automatically calls libvlc_media_parse_async(), so after calling<br>
     * it you may receive a libvlc_MediaMetaChanged event. If you prefer a synchronous<br>
     * version ensure that you call libvlc_media_parse() before get_meta().<br>
     * \see libvlc_media_parse<br>
     * \see libvlc_media_parse_async<br>
     * \see libvlc_MediaMetaChanged<br>
     * \param p_md the media descriptor<br>
     * \param e_meta the meta to read<br>
     * \return the media's meta<br>
     * Original signature : <code>char* libvlc_media_get_meta(libvlc_media_t*, libvlc_meta_t)</code><br>
     * <i>native declaration : line 1238</i>
     */
    public static native Pointer<Byte > libvlc_media_get_meta(Pointer<LibvlcLibrary.libvlc_media_t > p_md, IntValuedEnum<LibvlcLibrary.libvlc_meta_t > e_meta);
    /**
     * Set the meta of the media (this function will not save the meta, call<br>
     * libvlc_media_save_meta in order to save the meta)<br>
     * \param p_md the media descriptor<br>
     * \param e_meta the meta to write<br>
     * \param psz_value the media's meta<br>
     * Original signature : <code>void libvlc_media_set_meta(libvlc_media_t*, libvlc_meta_t, const char*)</code><br>
     * <i>native declaration : line 1249</i>
     */
    public static native void libvlc_media_set_meta(Pointer<LibvlcLibrary.libvlc_media_t > p_md, IntValuedEnum<LibvlcLibrary.libvlc_meta_t > e_meta, Pointer<Byte > psz_value);
    /**
     * Save the meta previously set<br>
     * \param p_md the media desriptor<br>
     * \return true if the write operation was successful<br>
     * Original signature : <code>int libvlc_media_save_meta(libvlc_media_t*)</code><br>
     * <i>native declaration : line 1260</i>
     */
    public static native int libvlc_media_save_meta(Pointer<LibvlcLibrary.libvlc_media_t > p_md);
    /**
     * Get current state of media descriptor object. Possible media states<br>
     * are defined in libvlc_structures.c ( libvlc_NothingSpecial=0,<br>
     * libvlc_Opening, libvlc_Buffering, libvlc_Playing, libvlc_Paused,<br>
     * libvlc_Stopped, libvlc_Ended,<br>
     * libvlc_Error).<br>
     * \see libvlc_state_t<br>
     * \param p_md a media descriptor object<br>
     * \return state of media descriptor object<br>
     * Original signature : <code>libvlc_state_t libvlc_media_get_state(libvlc_media_t*)</code><br>
     * <i>native declaration : line 1274</i>
     */
    public static native IntValuedEnum<LibvlcLibrary.libvlc_state_t > libvlc_media_get_state(Pointer<LibvlcLibrary.libvlc_media_t > p_md);
    /**
     * Get the current statistics about the media<br>
     * \param p_md: media descriptor object<br>
     * \param p_stats: structure that contain the statistics about the media<br>
     *                 (this structure must be allocated by the caller)<br>
     * \return true if the statistics are available, false otherwise<br>
     * \libvlc_return_bool<br>
     * Original signature : <code>int libvlc_media_get_stats(libvlc_media_t*, libvlc_media_stats_t*)</code><br>
     * <i>native declaration : line 1287</i>
     */
    public static native int libvlc_media_get_stats(Pointer<LibvlcLibrary.libvlc_media_t > p_md, Pointer<libvlc_media_stats_t > p_stats);
    /**
     * Get subitems of media descriptor object. This will increment<br>
     * the reference count of supplied media descriptor object. Use<br>
     * libvlc_media_list_release() to decrement the reference counting.<br>
     * \param p_md media descriptor object<br>
     * \return list of media descriptor subitems or NULL<br>
     * Original signature : <code>libvlc_media_list_t* libvlc_media_subitems(libvlc_media_t*)</code><br>
     * <i>native declaration : line 1302</i>
     */
    public static native Pointer<LibvlcLibrary.libvlc_media_list_t > libvlc_media_subitems(Pointer<LibvlcLibrary.libvlc_media_t > p_md);
    /**
     * Get event manager from media descriptor object.<br>
     * NOTE: this function doesn't increment reference counting.<br>
     * \param p_md a media descriptor object<br>
     * \return event manager object<br>
     * Original signature : <code>libvlc_event_manager_t* libvlc_media_event_manager(libvlc_media_t*)</code><br>
     * <i>native declaration : line 1312</i>
     */
    public static native Pointer<LibvlcLibrary.libvlc_event_manager_t > libvlc_media_event_manager(Pointer<LibvlcLibrary.libvlc_media_t > p_md);
    /**
     * Get duration (in ms) of media descriptor object item.<br>
     * \param p_md media descriptor object<br>
     * \return duration of media item or -1 on error<br>
     * Original signature : <code>libvlc_time_t libvlc_media_get_duration(libvlc_media_t*)</code><br>
     * <i>native declaration : line 1321</i>
     */
    public static native long libvlc_media_get_duration(Pointer<LibvlcLibrary.libvlc_media_t > p_md);
    /**
     * Parse a media.<br>
     * This fetches (local) art, meta data and tracks information.<br>
     * The method is synchronous.<br>
     * \see libvlc_media_parse_async<br>
     * \see libvlc_media_get_meta<br>
     * \see libvlc_media_get_tracks_info<br>
     * \param p_md media descriptor object<br>
     * Original signature : <code>void libvlc_media_parse(libvlc_media_t*)</code><br>
     * <i>native declaration : line 1336</i>
     */
    public static native void libvlc_media_parse(Pointer<LibvlcLibrary.libvlc_media_t > p_md);
    /**
     * Parse a media.<br>
     * This fetches (local) art, meta data and tracks information.<br>
     * The method is the asynchronous of libvlc_media_parse().<br>
     * To track when this is over you can listen to libvlc_MediaParsedChanged<br>
     * event. However if the media was already parsed you will not receive this<br>
     * event.<br>
     * \see libvlc_media_parse<br>
     * \see libvlc_MediaParsedChanged<br>
     * \see libvlc_media_get_meta<br>
     * \see libvlc_media_get_tracks_info<br>
     * \param p_md media descriptor object<br>
     * Original signature : <code>void libvlc_media_parse_async(libvlc_media_t*)</code><br>
     * <i>native declaration : line 1356</i>
     */
    public static native void libvlc_media_parse_async(Pointer<LibvlcLibrary.libvlc_media_t > p_md);
    /**
     * Parse the media asynchronously with options.<br>
     * This fetches (local or network) art, meta data and/or tracks information.<br>
     * This method is the extended version of libvlc_media_parse_async().<br>
     * To track when this is over you can listen to libvlc_MediaParsedChanged<br>
     * event. However if this functions returns an error, you will not receive this<br>
     * event.<br>
     * It uses a flag to specify parse options (see libvlc_media_parse_flag_t). All<br>
     * these flags can be combined. By default, media is parsed if it's a local<br>
     * file.<br>
     * \see libvlc_MediaParsedChanged<br>
     * \see libvlc_media_get_meta<br>
     * \see libvlc_media_tracks_get<br>
     * \see libvlc_media_parse_flag_t<br>
     * \param p_md media descriptor object<br>
     * \param parse_flag parse options:<br>
     * \return -1 in case of error, 0 otherwise<br>
     * \version LibVLC 3.0.0 or later<br>
     * Original signature : <code>int libvlc_media_parse_with_options(libvlc_media_t*, libvlc_media_parse_flag_t)</code><br>
     * <i>native declaration : line 1383</i>
     */
    public static native int libvlc_media_parse_with_options(Pointer<LibvlcLibrary.libvlc_media_t > p_md, IntValuedEnum<LibvlcLibrary.libvlc_media_parse_flag_t > parse_flag);
    /**
     * Get Parsed status for media descriptor object.<br>
     * \see libvlc_MediaParsedChanged<br>
     * \param p_md media descriptor object<br>
     * \return true if media object has been parsed otherwise it returns false<br>
     * \libvlc_return_bool<br>
     * Original signature : <code>int libvlc_media_is_parsed(libvlc_media_t*)</code><br>
     * <i>native declaration : line 1397</i>
     */
    public static native int libvlc_media_is_parsed(Pointer<LibvlcLibrary.libvlc_media_t > p_md);
    /**
     * Sets media descriptor's user_data. user_data is specialized data<br>
     * accessed by the host application, VLC.framework uses it as a pointer to<br>
     * an native object that references a libvlc_media_t pointer<br>
     * \param p_md media descriptor object<br>
     * \param p_new_user_data pointer to user data<br>
     * Original signature : <code>void libvlc_media_set_user_data(libvlc_media_t*, void*)</code><br>
     * <i>native declaration : line 1408</i>
     */
    public static native void libvlc_media_set_user_data(Pointer<LibvlcLibrary.libvlc_media_t > p_md, Pointer<? > p_new_user_data);
    /**
     * Get media descriptor's user_data. user_data is specialized data<br>
     * accessed by the host application, VLC.framework uses it as a pointer to<br>
     * an native object that references a libvlc_media_t pointer<br>
     * \param p_md media descriptor object<br>
     * Original signature : <code>void* libvlc_media_get_user_data(libvlc_media_t*)</code><br>
     * <i>native declaration : line 1418</i>
     */
    public static native Pointer<? > libvlc_media_get_user_data(Pointer<LibvlcLibrary.libvlc_media_t > p_md);
    /**
     * Get media descriptor's elementary streams description<br>
     * Note, you need to call libvlc_media_parse() or play the media at least once<br>
     * before calling this function.<br>
     * Not doing this will result in an empty array.<br>
     * \deprecated Use libvlc_media_tracks_get instead<br>
     * \param p_md media descriptor object<br>
     * \param tracks address to store an allocated array of Elementary Streams<br>
     *        descriptions (must be freed by the caller) [OUT]<br>
     * \return the number of Elementary Streams<br>
     * Original signature : <code>int libvlc_media_get_tracks_info(libvlc_media_t*, libvlc_media_track_info_t**)</code><br>
     * <i>native declaration : line 1436</i>
     */
    public static native int libvlc_media_get_tracks_info(Pointer<LibvlcLibrary.libvlc_media_t > p_md, Pointer<Pointer<libvlc_media_track_info_t > > tracks);
    /**
     * Get media descriptor's elementary streams description<br>
     * Note, you need to call libvlc_media_parse() or play the media at least once<br>
     * before calling this function.<br>
     * Not doing this will result in an empty array.<br>
     * \version LibVLC 2.1.0 and later.<br>
     * \param p_md media descriptor object<br>
     * \param tracks address to store an allocated array of Elementary Streams<br>
     *        descriptions (must be freed with libvlc_media_tracks_release<br>
     * by the caller) [OUT]<br>
     * \return the number of Elementary Streams (zero on error)<br>
     * Original signature : <code>int libvlc_media_tracks_get(libvlc_media_t*, libvlc_media_track_t***)</code><br>
     * <i>native declaration : line 1456</i>
     */
    public static native int libvlc_media_tracks_get(Pointer<LibvlcLibrary.libvlc_media_t > p_md, Pointer<Pointer<Pointer<libvlc_media_track_t > > > tracks);
    /**
     * Get codec description from media elementary stream<br>
     * \version LibVLC 3.0.0 and later.<br>
     * \see libvlc_media_track_t<br>
     * \param i_type i_type from libvlc_media_track_t<br>
     * \param i_codec i_codec or i_original_fourcc from libvlc_media_track_t<br>
     * \return codec description<br>
     * Original signature : <code>char* libvlc_media_get_codec_description(libvlc_track_type_t, uint32_t)</code><br>
     * <i>native declaration : line 1472</i>
     */
    public static native Pointer<Byte > libvlc_media_get_codec_description(IntValuedEnum<LibvlcLibrary.libvlc_track_type_t > i_type, int i_codec);
    /**
     * Release media descriptor's elementary streams description array<br>
     * \version LibVLC 2.1.0 and later.<br>
     * \param p_tracks tracks info array to release<br>
     * \param i_count number of elements in the array<br>
     * Original signature : <code>void libvlc_media_tracks_release(libvlc_media_track_t**, unsigned)</code><br>
     * <i>native declaration : line 1484</i>
     */
    public static native void libvlc_media_tracks_release(Pointer<Pointer<libvlc_media_track_t > > p_tracks, int i_count);
    /**
     * Get the media type of the media descriptor object<br>
     * \version LibVLC 3.0.0 and later.<br>
     * \see libvlc_media_type_t<br>
     * \param p_md media descriptor object<br>
     * \return media type<br>
     * Original signature : <code>libvlc_media_type_t libvlc_media_get_type(libvlc_media_t*)</code><br>
     * <i>native declaration : line 1499</i>
     */
    public static native IntValuedEnum<LibvlcLibrary.libvlc_media_type_t > libvlc_media_get_type(Pointer<LibvlcLibrary.libvlc_media_t > p_md);
    /**
     * Create an empty Media Player object<br>
     * \param p_libvlc_instance the libvlc instance in which the Media Player<br>
     *        should be created.<br>
     * \return a new media player object, or NULL on error.<br>
     * Original signature : <code>libvlc_media_player_t* libvlc_media_player_new(libvlc_instance_t*)</code><br>
     * <i>native declaration : line 1660</i>
     */
    public static native Pointer<LibvlcLibrary.libvlc_media_player_t > libvlc_media_player_new(Pointer<LibvlcLibrary.libvlc_instance_t > p_libvlc_instance);
    /**
     * Create a Media Player object from a Media<br>
     * \param p_md the media. Afterwards the p_md can be safely<br>
     *        destroyed.<br>
     * \return a new media player object, or NULL on error.<br>
     * Original signature : <code>libvlc_media_player_t* libvlc_media_player_new_from_media(libvlc_media_t*)</code><br>
     * <i>native declaration : line 1669</i>
     */
    public static native Pointer<LibvlcLibrary.libvlc_media_player_t > libvlc_media_player_new_from_media(Pointer<LibvlcLibrary.libvlc_media_t > p_md);
    /**
     * Release a media_player after use<br>
     * Decrement the reference count of a media player object. If the<br>
     * reference count is 0, then libvlc_media_player_release() will<br>
     * release the media player object. If the media player object<br>
     * has been released, then it should not be used again.<br>
     * \param p_mi the Media Player to free<br>
     * Original signature : <code>void libvlc_media_player_release(libvlc_media_player_t*)</code><br>
     * <i>native declaration : line 1680</i>
     */
    public static native void libvlc_media_player_release(Pointer<LibvlcLibrary.libvlc_media_player_t > p_mi);
    /**
     * Retain a reference to a media player object. Use<br>
     * libvlc_media_player_release() to decrement reference count.<br>
     * \param p_mi media player object<br>
     * Original signature : <code>void libvlc_media_player_retain(libvlc_media_player_t*)</code><br>
     * <i>native declaration : line 1688</i>
     */
    public static native void libvlc_media_player_retain(Pointer<LibvlcLibrary.libvlc_media_player_t > p_mi);
    /**
     * Set the media that will be used by the media_player. If any,<br>
     * previous md will be released.<br>
     * \param p_mi the Media Player<br>
     * \param p_md the Media. Afterwards the p_md can be safely<br>
     *        destroyed.<br>
     * Original signature : <code>void libvlc_media_player_set_media(libvlc_media_player_t*, libvlc_media_t*)</code><br>
     * <i>native declaration : line 1698</i>
     */
    public static native void libvlc_media_player_set_media(Pointer<LibvlcLibrary.libvlc_media_player_t > p_mi, Pointer<LibvlcLibrary.libvlc_media_t > p_md);
    /**
     * Get the media used by the media_player.<br>
     * \param p_mi the Media Player<br>
     * \return the media associated with p_mi, or NULL if no<br>
     *         media is associated<br>
     * Original signature : <code>libvlc_media_t* libvlc_media_player_get_media(libvlc_media_player_t*)</code><br>
     * <i>native declaration : line 1708</i>
     */
    public static native Pointer<LibvlcLibrary.libvlc_media_t > libvlc_media_player_get_media(Pointer<LibvlcLibrary.libvlc_media_player_t > p_mi);
    /**
     * Get the Event Manager from which the media player send event.<br>
     * \param p_mi the Media Player<br>
     * \return the event manager associated with p_mi<br>
     * Original signature : <code>libvlc_event_manager_t* libvlc_media_player_event_manager(libvlc_media_player_t*)</code><br>
     * <i>native declaration : line 1716</i>
     */
    public static native Pointer<LibvlcLibrary.libvlc_event_manager_t > libvlc_media_player_event_manager(Pointer<LibvlcLibrary.libvlc_media_player_t > p_mi);
    /**
     * is_playing<br>
     * \param p_mi the Media Player<br>
     * \return 1 if the media player is playing, 0 otherwise<br>
     * \libvlc_return_bool<br>
     * Original signature : <code>int libvlc_media_player_is_playing(libvlc_media_player_t*)</code><br>
     * <i>native declaration : line 1726</i>
     */
    public static native int libvlc_media_player_is_playing(Pointer<LibvlcLibrary.libvlc_media_player_t > p_mi);
    /**
     * Play<br>
     * \param p_mi the Media Player<br>
     * \return 0 if playback started (and was already started), or -1 on error.<br>
     * Original signature : <code>int libvlc_media_player_play(libvlc_media_player_t*)</code><br>
     * <i>native declaration : line 1734</i>
     */
    public static native int libvlc_media_player_play(Pointer<LibvlcLibrary.libvlc_media_player_t > p_mi);
    /**
     * Pause or resume (no effect if there is no media)<br>
     * \param mp the Media Player<br>
     * \param do_pause play/resume if zero, pause if non-zero<br>
     * \version LibVLC 1.1.1 or later<br>
     * Original signature : <code>void libvlc_media_player_set_pause(libvlc_media_player_t*, int)</code><br>
     * <i>native declaration : line 1743</i>
     */
    public static native void libvlc_media_player_set_pause(Pointer<LibvlcLibrary.libvlc_media_player_t > mp, int do_pause);
    /**
     * Toggle pause (no effect if there is no media)<br>
     * \param p_mi the Media Player<br>
     * Original signature : <code>void libvlc_media_player_pause(libvlc_media_player_t*)</code><br>
     * <i>native declaration : line 1751</i>
     */
    public static native void libvlc_media_player_pause(Pointer<LibvlcLibrary.libvlc_media_player_t > p_mi);
    /**
     * Stop (no effect if there is no media)<br>
     * \param p_mi the Media Player<br>
     * Original signature : <code>void libvlc_media_player_stop(libvlc_media_player_t*)</code><br>
     * <i>native declaration : line 1758</i>
     */
    public static native void libvlc_media_player_stop(Pointer<LibvlcLibrary.libvlc_media_player_t > p_mi);
    /**
     * Set callbacks and private data to render decoded video to a custom area<br>
     * in memory.<br>
     * Use libvlc_video_set_format() or libvlc_video_set_format_callbacks()<br>
     * to configure the decoded format.<br>
     * \param mp the media player<br>
     * \param lock callback to lock video memory (must not be NULL)<br>
     * \param unlock callback to unlock video memory (or NULL if not needed)<br>
     * \param display callback to display video (or NULL if not needed)<br>
     * \param opaque private pointer for the three callbacks (as first parameter)<br>
     * \version LibVLC 1.1.1 or later<br>
     * Original signature : <code>void libvlc_video_set_callbacks(libvlc_media_player_t*, libvlc_video_lock_cb, libvlc_video_unlock_cb, libvlc_video_display_cb, void*)</code><br>
     * <i>native declaration : line 1861</i>
     */
    public static native void libvlc_video_set_callbacks(Pointer<LibvlcLibrary.libvlc_media_player_t > mp, Pointer<LibvlcLibrary.libvlc_video_lock_cb > lock, Pointer<LibvlcLibrary.libvlc_video_unlock_cb > unlock, Pointer<LibvlcLibrary.libvlc_video_display_cb > display, Pointer<? > opaque);
    /**
     * Set decoded video chroma and dimensions.<br>
     * This only works in combination with libvlc_video_set_callbacks(),<br>
     * and is mutually exclusive with libvlc_video_set_format_callbacks().<br>
     * \param mp the media player<br>
     * \param chroma a four-characters string identifying the chroma<br>
     *               (e.g. "RV32" or "YUYV")<br>
     * \param width pixel width<br>
     * \param height pixel height<br>
     * \param pitch line pitch (in bytes)<br>
     * \version LibVLC 1.1.1 or later<br>
     * \bug All pixel planes are expected to have the same pitch.<br>
     * To use the YCbCr color space with chrominance subsampling,<br>
     * consider using libvlc_video_set_format_callbacks() instead.<br>
     * Original signature : <code>void libvlc_video_set_format(libvlc_media_player_t*, const char*, unsigned, unsigned, unsigned)</code><br>
     * <i>native declaration : line 1884</i>
     */
    public static native void libvlc_video_set_format(Pointer<LibvlcLibrary.libvlc_media_player_t > mp, Pointer<Byte > chroma, int width, int height, int pitch);
    /**
     * Set decoded video chroma and dimensions. This only works in combination with<br>
     * libvlc_video_set_callbacks().<br>
     * \param mp the media player<br>
     * \param setup callback to select the video format (cannot be NULL)<br>
     * \param cleanup callback to release any allocated resources (or NULL)<br>
     * \version LibVLC 2.0.0 or later<br>
     * Original signature : <code>void libvlc_video_set_format_callbacks(libvlc_media_player_t*, libvlc_video_format_cb, libvlc_video_cleanup_cb)</code><br>
     * <i>native declaration : line 1898</i>
     */
    public static native void libvlc_video_set_format_callbacks(Pointer<LibvlcLibrary.libvlc_media_player_t > mp, Pointer<LibvlcLibrary.libvlc_video_format_cb > setup, Pointer<LibvlcLibrary.libvlc_video_cleanup_cb > cleanup);
    /**
     * Set the NSView handler where the media player should render its video output.<br>
     * Use the vout called "macosx".<br>
     * The drawable is an NSObject that follow the VLCOpenGLVideoViewEmbedding<br>
     * protocol:<br>
     * @begincode<br>
     * \@protocol VLCOpenGLVideoViewEmbedding <NSObject><br>
     * - (void)addVoutSubview:(NSView *)view;<br>
     * - (void)removeVoutSubview:(NSView *)view;<br>
     * \@end<br>
     * @endcode<br>
     * Or it can be an NSView object.<br>
     * If you want to use it along with Qt4 see the QMacCocoaViewContainer. Then<br>
     * the following code should work:<br>
     * @begincode<br>
     * {<br>
     *     NSView *video = [[NSView alloc] init];<br>
     *     QMacCocoaViewContainer *container = new QMacCocoaViewContainer(video, parent);<br>
     *     libvlc_media_player_set_nsobject(mp, video);<br>
     *     [video release];<br>
     * }<br>
     * @endcode<br>
     * You can find a live example in VLCVideoView in VLCKit.framework.<br>
     * \param p_mi the Media Player<br>
     * \param drawable the drawable that is either an NSView or an object following<br>
     * the VLCOpenGLVideoViewEmbedding protocol.<br>
     * Original signature : <code>void libvlc_media_player_set_nsobject(libvlc_media_player_t*, void*)</code><br>
     * <i>native declaration : line 1936</i>
     */
    public static native void libvlc_media_player_set_nsobject(Pointer<LibvlcLibrary.libvlc_media_player_t > p_mi, Pointer<? > drawable);
    /**
     * Get the NSView handler previously set with libvlc_media_player_set_nsobject().<br>
     * \param p_mi the Media Player<br>
     * \return the NSView handler or 0 if none where set<br>
     * Original signature : <code>void* libvlc_media_player_get_nsobject(libvlc_media_player_t*)</code><br>
     * <i>native declaration : line 1944</i>
     */
    public static native Pointer<? > libvlc_media_player_get_nsobject(Pointer<LibvlcLibrary.libvlc_media_player_t > p_mi);
    /**
     * Set the agl handler where the media player should render its video output.<br>
     * \param p_mi the Media Player<br>
     * \param drawable the agl handler<br>
     * Original signature : <code>void libvlc_media_player_set_agl(libvlc_media_player_t*, uint32_t)</code><br>
     * <i>native declaration : line 1952</i>
     */
    public static native void libvlc_media_player_set_agl(Pointer<LibvlcLibrary.libvlc_media_player_t > p_mi, int drawable);
    /**
     * Get the agl handler previously set with libvlc_media_player_set_agl().<br>
     * \param p_mi the Media Player<br>
     * \return the agl handler or 0 if none where set<br>
     * Original signature : <code>uint32_t libvlc_media_player_get_agl(libvlc_media_player_t*)</code><br>
     * <i>native declaration : line 1960</i>
     */
    public static native int libvlc_media_player_get_agl(Pointer<LibvlcLibrary.libvlc_media_player_t > p_mi);
    /**
     * Set an X Window System drawable where the media player should render its<br>
     * video output. If LibVLC was built without X11 output support, then this has<br>
     * no effects.<br>
     * The specified identifier must correspond to an existing Input/Output class<br>
     * X11 window. Pixmaps are <b>not</b> supported. The caller shall ensure that<br>
     * the X11 server is the same as the one the VLC instance has been configured<br>
     * with. This function must be called before video playback is started;<br>
     * otherwise it will only take effect after playback stop and restart.<br>
     * \param p_mi the Media Player<br>
     * \param drawable the ID of the X window<br>
     * Original signature : <code>void libvlc_media_player_set_xwindow(libvlc_media_player_t*, uint32_t)</code><br>
     * <i>native declaration : line 1976</i>
     */
    public static native void libvlc_media_player_set_xwindow(Pointer<LibvlcLibrary.libvlc_media_player_t > p_mi, int drawable);
    /**
     * Get the X Window System window identifier previously set with<br>
     * libvlc_media_player_set_xwindow(). Note that this will return the identifier<br>
     * even if VLC is not currently using it (for instance if it is playing an<br>
     * audio-only input).<br>
     * \param p_mi the Media Player<br>
     * \return an X window ID, or 0 if none where set.<br>
     * Original signature : <code>uint32_t libvlc_media_player_get_xwindow(libvlc_media_player_t*)</code><br>
     * <i>native declaration : line 1987</i>
     */
    public static native int libvlc_media_player_get_xwindow(Pointer<LibvlcLibrary.libvlc_media_player_t > p_mi);
    /**
     * Set a Win32/Win64 API window handle (HWND) where the media player should<br>
     * render its video output. If LibVLC was built without Win32/Win64 API output<br>
     * support, then this has no effects.<br>
     * \param p_mi the Media Player<br>
     * \param drawable windows handle of the drawable<br>
     * Original signature : <code>void libvlc_media_player_set_hwnd(libvlc_media_player_t*, void*)</code><br>
     * <i>native declaration : line 1997</i>
     */
    public static native void libvlc_media_player_set_hwnd(Pointer<LibvlcLibrary.libvlc_media_player_t > p_mi, Pointer<? > drawable);
    /**
     * Get the Windows API window handle (HWND) previously set with<br>
     * libvlc_media_player_set_hwnd(). The handle will be returned even if LibVLC<br>
     * is not currently outputting any video to it.<br>
     * \param p_mi the Media Player<br>
     * \return a window handle or NULL if there are none.<br>
     * Original signature : <code>void* libvlc_media_player_get_hwnd(libvlc_media_player_t*)</code><br>
     * <i>native declaration : line 2007</i>
     */
    public static native Pointer<? > libvlc_media_player_get_hwnd(Pointer<LibvlcLibrary.libvlc_media_player_t > p_mi);
    /**
     * Set callbacks and private data for decoded audio.<br>
     * Use libvlc_audio_set_format() or libvlc_audio_set_format_callbacks()<br>
     * to configure the decoded audio format.<br>
     * \param mp the media player<br>
     * \param play callback to play audio samples (must not be NULL)<br>
     * \param pause callback to pause playback (or NULL to ignore)<br>
     * \param resume callback to resume playback (or NULL to ignore)<br>
     * \param flush callback to flush audio buffers (or NULL to ignore)<br>
     * \param drain callback to drain audio buffers (or NULL to ignore)<br>
     * \param opaque private pointer for the audio callbacks (as first parameter)<br>
     * \version LibVLC 2.0.0 or later<br>
     * Original signature : <code>void libvlc_audio_set_callbacks(libvlc_media_player_t*, libvlc_audio_play_cb, libvlc_audio_pause_cb, libvlc_audio_resume_cb, libvlc_audio_flush_cb, libvlc_audio_drain_cb, void*)</code><br>
     * <i>native declaration : line 2073</i>
     */
    public static native void libvlc_audio_set_callbacks(Pointer<LibvlcLibrary.libvlc_media_player_t > mp, Pointer<LibvlcLibrary.libvlc_audio_play_cb > play, Pointer<LibvlcLibrary.libvlc_audio_pause_cb > pause, Pointer<LibvlcLibrary.libvlc_audio_resume_cb > resume, Pointer<LibvlcLibrary.libvlc_audio_flush_cb > flush, Pointer<LibvlcLibrary.libvlc_audio_drain_cb > drain, Pointer<? > opaque);
    /**
     * Set callbacks and private data for decoded audio. This only works in<br>
     * combination with libvlc_audio_set_callbacks().<br>
     * Use libvlc_audio_set_format() or libvlc_audio_set_format_callbacks()<br>
     * to configure the decoded audio format.<br>
     * \param mp the media player<br>
     * \param set_volume callback to apply audio volume,<br>
     *                   or NULL to apply volume in software<br>
     * \version LibVLC 2.0.0 or later<br>
     * Original signature : <code>void libvlc_audio_set_volume_callback(libvlc_media_player_t*, libvlc_audio_set_volume_cb)</code><br>
     * <i>native declaration : line 2093</i>
     */
    public static native void libvlc_audio_set_volume_callback(Pointer<LibvlcLibrary.libvlc_media_player_t > mp, Pointer<LibvlcLibrary.libvlc_audio_set_volume_cb > set_volume);
    /**
     * Set decoded audio format. This only works in combination with<br>
     * libvlc_audio_set_callbacks().<br>
     * \param mp the media player<br>
     * \param setup callback to select the audio format (cannot be NULL)<br>
     * \param cleanup callback to release any allocated resources (or NULL)<br>
     * \version LibVLC 2.0.0 or later<br>
     * Original signature : <code>void libvlc_audio_set_format_callbacks(libvlc_media_player_t*, libvlc_audio_setup_cb, libvlc_audio_cleanup_cb)</code><br>
     * <i>native declaration : line 2126</i>
     */
    public static native void libvlc_audio_set_format_callbacks(Pointer<LibvlcLibrary.libvlc_media_player_t > mp, Pointer<LibvlcLibrary.libvlc_audio_setup_cb > setup, Pointer<LibvlcLibrary.libvlc_audio_cleanup_cb > cleanup);
    /**
     * Set decoded audio format.<br>
     * This only works in combination with libvlc_audio_set_callbacks(),<br>
     * and is mutually exclusive with libvlc_audio_set_format_callbacks().<br>
     * \param mp the media player<br>
     * \param format a four-characters string identifying the sample format<br>
     *               (e.g. "S16N" or "FL32")<br>
     * \param rate sample rate (expressed in Hz)<br>
     * \param channels channels count<br>
     * \version LibVLC 2.0.0 or later<br>
     * Original signature : <code>void libvlc_audio_set_format(libvlc_media_player_t*, const char*, unsigned, unsigned)</code><br>
     * <i>native declaration : line 2143</i>
     */
    public static native void libvlc_audio_set_format(Pointer<LibvlcLibrary.libvlc_media_player_t > mp, Pointer<Byte > format, int rate, int channels);
    /**
     * Get the current movie length (in ms).<br>
     * \param p_mi the Media Player<br>
     * \return the movie length (in ms), or -1 if there is no media.<br>
     * Original signature : <code>libvlc_time_t libvlc_media_player_get_length(libvlc_media_player_t*)</code><br>
     * <i>native declaration : line 2154</i>
     */
    public static native long libvlc_media_player_get_length(Pointer<LibvlcLibrary.libvlc_media_player_t > p_mi);
    /**
     * Get the current movie time (in ms).<br>
     * \param p_mi the Media Player<br>
     * \return the movie time (in ms), or -1 if there is no media.<br>
     * Original signature : <code>libvlc_time_t libvlc_media_player_get_time(libvlc_media_player_t*)</code><br>
     * <i>native declaration : line 2162</i>
     */
    public static native long libvlc_media_player_get_time(Pointer<LibvlcLibrary.libvlc_media_player_t > p_mi);
    /**
     * Set the movie time (in ms). This has no effect if no media is being played.<br>
     * Not all formats and protocols support this.<br>
     * \param p_mi the Media Player<br>
     * \param i_time the movie time (in ms).<br>
     * Original signature : <code>void libvlc_media_player_set_time(libvlc_media_player_t*, libvlc_time_t)</code><br>
     * <i>native declaration : line 2171</i>
     */
    public static native void libvlc_media_player_set_time(Pointer<LibvlcLibrary.libvlc_media_player_t > p_mi, long i_time);
    /**
     * Get movie position as percentage between 0.0 and 1.0.<br>
     * \param p_mi the Media Player<br>
     * \return movie position, or -1. in case of error<br>
     * Original signature : <code>float libvlc_media_player_get_position(libvlc_media_player_t*)</code><br>
     * <i>native declaration : line 2179</i>
     */
    public static native float libvlc_media_player_get_position(Pointer<LibvlcLibrary.libvlc_media_player_t > p_mi);
    /**
     * Set movie position as percentage between 0.0 and 1.0. <br>
     * This has no effect if playback is not enabled.<br>
     * This might not work depending on the underlying input format and protocol.<br>
     * \param p_mi the Media Player<br>
     * \param f_pos the position<br>
     * Original signature : <code>void libvlc_media_player_set_position(libvlc_media_player_t*, float)</code><br>
     * <i>native declaration : line 2189</i>
     */
    public static native void libvlc_media_player_set_position(Pointer<LibvlcLibrary.libvlc_media_player_t > p_mi, float f_pos);
    /**
     * Set movie chapter (if applicable).<br>
     * \param p_mi the Media Player<br>
     * \param i_chapter chapter number to play<br>
     * Original signature : <code>void libvlc_media_player_set_chapter(libvlc_media_player_t*, int)</code><br>
     * <i>native declaration : line 2197</i>
     */
    public static native void libvlc_media_player_set_chapter(Pointer<LibvlcLibrary.libvlc_media_player_t > p_mi, int i_chapter);
    /**
     * Get movie chapter.<br>
     * \param p_mi the Media Player<br>
     * \return chapter number currently playing, or -1 if there is no media.<br>
     * Original signature : <code>int libvlc_media_player_get_chapter(libvlc_media_player_t*)</code><br>
     * <i>native declaration : line 2205</i>
     */
    public static native int libvlc_media_player_get_chapter(Pointer<LibvlcLibrary.libvlc_media_player_t > p_mi);
    /**
     * Get movie chapter count<br>
     * \param p_mi the Media Player<br>
     * \return number of chapters in movie, or -1.<br>
     * Original signature : <code>int libvlc_media_player_get_chapter_count(libvlc_media_player_t*)</code><br>
     * <i>native declaration : line 2213</i>
     */
    public static native int libvlc_media_player_get_chapter_count(Pointer<LibvlcLibrary.libvlc_media_player_t > p_mi);
    /**
     * Is the player able to play<br>
     * \param p_mi the Media Player<br>
     * \return boolean<br>
     * \libvlc_return_bool<br>
     * Original signature : <code>int libvlc_media_player_will_play(libvlc_media_player_t*)</code><br>
     * <i>native declaration : line 2223</i>
     */
    public static native int libvlc_media_player_will_play(Pointer<LibvlcLibrary.libvlc_media_player_t > p_mi);
    /**
     * Get title chapter count<br>
     * \param p_mi the Media Player<br>
     * \param i_title title<br>
     * \return number of chapters in title, or -1<br>
     * Original signature : <code>int libvlc_media_player_get_chapter_count_for_title(libvlc_media_player_t*, int)</code><br>
     * <i>native declaration : line 2232</i>
     */
    public static native int libvlc_media_player_get_chapter_count_for_title(Pointer<LibvlcLibrary.libvlc_media_player_t > p_mi, int i_title);
    /**
     * Set movie title<br>
     * \param p_mi the Media Player<br>
     * \param i_title title number to play<br>
     * Original signature : <code>void libvlc_media_player_set_title(libvlc_media_player_t*, int)</code><br>
     * <i>native declaration : line 2241</i>
     */
    public static native void libvlc_media_player_set_title(Pointer<LibvlcLibrary.libvlc_media_player_t > p_mi, int i_title);
    /**
     * Get movie title<br>
     * \param p_mi the Media Player<br>
     * \return title number currently playing, or -1<br>
     * Original signature : <code>int libvlc_media_player_get_title(libvlc_media_player_t*)</code><br>
     * <i>native declaration : line 2249</i>
     */
    public static native int libvlc_media_player_get_title(Pointer<LibvlcLibrary.libvlc_media_player_t > p_mi);
    /**
     * Get movie title count<br>
     * \param p_mi the Media Player<br>
     * \return title number count, or -1<br>
     * Original signature : <code>int libvlc_media_player_get_title_count(libvlc_media_player_t*)</code><br>
     * <i>native declaration : line 2257</i>
     */
    public static native int libvlc_media_player_get_title_count(Pointer<LibvlcLibrary.libvlc_media_player_t > p_mi);
    /**
     * Set previous chapter (if applicable)<br>
     * \param p_mi the Media Player<br>
     * Original signature : <code>void libvlc_media_player_previous_chapter(libvlc_media_player_t*)</code><br>
     * <i>native declaration : line 2264</i>
     */
    public static native void libvlc_media_player_previous_chapter(Pointer<LibvlcLibrary.libvlc_media_player_t > p_mi);
    /**
     * Set next chapter (if applicable)<br>
     * \param p_mi the Media Player<br>
     * Original signature : <code>void libvlc_media_player_next_chapter(libvlc_media_player_t*)</code><br>
     * <i>native declaration : line 2271</i>
     */
    public static native void libvlc_media_player_next_chapter(Pointer<LibvlcLibrary.libvlc_media_player_t > p_mi);
    /**
     * Get the requested movie play rate.<br>
     * @warning Depending on the underlying media, the requested rate may be<br>
     * different from the real playback rate.<br>
     * \param p_mi the Media Player<br>
     * \return movie play rate<br>
     * Original signature : <code>float libvlc_media_player_get_rate(libvlc_media_player_t*)</code><br>
     * <i>native declaration : line 2281</i>
     */
    public static native float libvlc_media_player_get_rate(Pointer<LibvlcLibrary.libvlc_media_player_t > p_mi);
    /**
     * Set movie play rate<br>
     * \param p_mi the Media Player<br>
     * \param rate movie play rate to set<br>
     * \return -1 if an error was detected, 0 otherwise (but even then, it might<br>
     * not actually work depending on the underlying media protocol)<br>
     * Original signature : <code>int libvlc_media_player_set_rate(libvlc_media_player_t*, float)</code><br>
     * <i>native declaration : line 2291</i>
     */
    public static native int libvlc_media_player_set_rate(Pointer<LibvlcLibrary.libvlc_media_player_t > p_mi, float rate);
    /**
     * Get current movie state<br>
     * \param p_mi the Media Player<br>
     * \return the current state of the media player (playing, paused, ...) \see libvlc_state_t<br>
     * Original signature : <code>libvlc_state_t libvlc_media_player_get_state(libvlc_media_player_t*)</code><br>
     * <i>native declaration : line 2299</i>
     */
    public static native IntValuedEnum<LibvlcLibrary.libvlc_state_t > libvlc_media_player_get_state(Pointer<LibvlcLibrary.libvlc_media_player_t > p_mi);
    /**
     * Get movie fps rate<br>
     * \param p_mi the Media Player<br>
     * \return frames per second (fps) for this playing movie, or 0 if unspecified<br>
     * Original signature : <code>float libvlc_media_player_get_fps(libvlc_media_player_t*)</code><br>
     * <i>native declaration : line 2307</i>
     */
    public static native float libvlc_media_player_get_fps(Pointer<LibvlcLibrary.libvlc_media_player_t > p_mi);
    /**
     * How many video outputs does this media player have?<br>
     * \param p_mi the media player<br>
     * \return the number of video outputs<br>
     * Original signature : <code>int libvlc_media_player_has_vout(libvlc_media_player_t*)</code><br>
     * <i>native declaration : line 2317</i>
     */
    public static native int libvlc_media_player_has_vout(Pointer<LibvlcLibrary.libvlc_media_player_t > p_mi);
    /**
     * Is this media player seekable?<br>
     * \param p_mi the media player<br>
     * \return true if the media player can seek<br>
     * \libvlc_return_bool<br>
     * Original signature : <code>int libvlc_media_player_is_seekable(libvlc_media_player_t*)</code><br>
     * <i>native declaration : line 2327</i>
     */
    public static native int libvlc_media_player_is_seekable(Pointer<LibvlcLibrary.libvlc_media_player_t > p_mi);
    /**
     * Can this media player be paused?<br>
     * \param p_mi the media player<br>
     * \return true if the media player can pause<br>
     * \libvlc_return_bool<br>
     * Original signature : <code>int libvlc_media_player_can_pause(libvlc_media_player_t*)</code><br>
     * <i>native declaration : line 2337</i>
     */
    public static native int libvlc_media_player_can_pause(Pointer<LibvlcLibrary.libvlc_media_player_t > p_mi);
    /**
     * Check if the current program is scrambled<br>
     * \param p_mi the media player<br>
     * \return true if the current program is scrambled<br>
     * \libvlc_return_bool<br>
     * \version LibVLC 2.2.0 or later<br>
     * Original signature : <code>int libvlc_media_player_program_scrambled(libvlc_media_player_t*)</code><br>
     * <i>native declaration : line 2348</i>
     */
    public static native int libvlc_media_player_program_scrambled(Pointer<LibvlcLibrary.libvlc_media_player_t > p_mi);
    /**
     * Display the next frame (if supported)<br>
     * \param p_mi the media player<br>
     * Original signature : <code>void libvlc_media_player_next_frame(libvlc_media_player_t*)</code><br>
     * <i>native declaration : line 2355</i>
     */
    public static native void libvlc_media_player_next_frame(Pointer<LibvlcLibrary.libvlc_media_player_t > p_mi);
    /**
     * Navigate through DVD Menu<br>
     * \param p_mi the Media Player<br>
     * \param navigate the Navigation mode<br>
     * \version libVLC 2.0.0 or later<br>
     * Original signature : <code>void libvlc_media_player_navigate(libvlc_media_player_t*, unsigned)</code><br>
     * <i>native declaration : line 2364</i>
     */
    public static native void libvlc_media_player_navigate(Pointer<LibvlcLibrary.libvlc_media_player_t > p_mi, int navigate);
    /**
     * Set if, and how, the video title will be shown when media is played.<br>
     * \param p_mi the media player<br>
     * \param position position at which to display the title, or libvlc_position_disable to prevent the title from being displayed<br>
     * \param timeout title display timeout in milliseconds (ignored if libvlc_position_disable)<br>
     * \version libVLC 2.1.0 or later<br>
     * Original signature : <code>void libvlc_media_player_set_video_title_display(libvlc_media_player_t*, libvlc_position_t, unsigned int)</code><br>
     * <i>native declaration : line 2375</i>
     */
    public static native void libvlc_media_player_set_video_title_display(Pointer<LibvlcLibrary.libvlc_media_player_t > p_mi, IntValuedEnum<LibvlcLibrary.libvlc_position_t > position, int timeout);
    /**
     * Release (free) libvlc_track_description_t<br>
     * \param p_track_description the structure to release<br>
     * Original signature : <code>void libvlc_track_description_list_release(libvlc_track_description_t*)</code><br>
     * <i>native declaration : line 2382</i>
     */
    public static native void libvlc_track_description_list_release(Pointer<libvlc_track_description_t > p_track_description);
    /**
     * \deprecated Use libvlc_track_description_list_release instead<br>
     * Original signature : <code>void libvlc_track_description_release(libvlc_track_description_t*)</code><br>
     * <i>native declaration : line 2388</i>
     */
    public static native void libvlc_track_description_release(Pointer<libvlc_track_description_t > p_track_description);
    /**
     * Toggle fullscreen status on non-embedded video outputs.<br>
     * @warning The same limitations applies to this function<br>
     * as to libvlc_set_fullscreen().<br>
     * \param p_mi the media player<br>
     * Original signature : <code>void libvlc_toggle_fullscreen(libvlc_media_player_t*)</code><br>
     * <i>native declaration : line 2402</i>
     */
    public static native void libvlc_toggle_fullscreen(Pointer<LibvlcLibrary.libvlc_media_player_t > p_mi);
    /**
     * Enable or disable fullscreen.<br>
     * @warning With most window managers, only a top-level windows can be in<br>
     * full-screen mode. Hence, this function will not operate properly if<br>
     * libvlc_media_player_set_xwindow() was used to embed the video in a<br>
     * non-top-level window. In that case, the embedding window must be reparented<br>
     * to the root window <b>before</b> fullscreen mode is enabled. You will want<br>
     * to reparent it back to its normal parent when disabling fullscreen.<br>
     * \param p_mi the media player<br>
     * \param b_fullscreen boolean for fullscreen status<br>
     * Original signature : <code>void libvlc_set_fullscreen(libvlc_media_player_t*, int)</code><br>
     * <i>native declaration : line 2417</i>
     */
    public static native void libvlc_set_fullscreen(Pointer<LibvlcLibrary.libvlc_media_player_t > p_mi, int b_fullscreen);
    /**
     * Get current fullscreen status.<br>
     * \param p_mi the media player<br>
     * \return the fullscreen status (boolean)<br>
     * \libvlc_return_bool<br>
     * Original signature : <code>int libvlc_get_fullscreen(libvlc_media_player_t*)</code><br>
     * <i>native declaration : line 2427</i>
     */
    public static native int libvlc_get_fullscreen(Pointer<LibvlcLibrary.libvlc_media_player_t > p_mi);
    /**
     * Enable or disable key press events handling, according to the LibVLC hotkeys<br>
     * configuration. By default and for historical reasons, keyboard events are<br>
     * handled by the LibVLC video widget.<br>
     * \note On X11, there can be only one subscriber for key press and mouse<br>
     * click events per window. If your application has subscribed to those events<br>
     * for the X window ID of the video widget, then LibVLC will not be able to<br>
     * handle key presses and mouse clicks in any case.<br>
     * \warning This function is only implemented for X11 and Win32 at the moment.<br>
     * \param p_mi the media player<br>
     * \param on true to handle key press events, false to ignore them.<br>
     * Original signature : <code>void libvlc_video_set_key_input(libvlc_media_player_t*, unsigned)</code><br>
     * <i>native declaration : line 2445</i>
     */
    public static native void libvlc_video_set_key_input(Pointer<LibvlcLibrary.libvlc_media_player_t > p_mi, int on);
    /**
     * Enable or disable mouse click events handling. By default, those events are<br>
     * handled. This is needed for DVD menus to work, as well as a few video<br>
     * filters such as "puzzle".<br>
     * \see libvlc_video_set_key_input().<br>
     * \warning This function is only implemented for X11 and Win32 at the moment.<br>
     * \param p_mi the media player<br>
     * \param on true to handle mouse click events, false to ignore them.<br>
     * Original signature : <code>void libvlc_video_set_mouse_input(libvlc_media_player_t*, unsigned)</code><br>
     * <i>native declaration : line 2460</i>
     */
    public static native void libvlc_video_set_mouse_input(Pointer<LibvlcLibrary.libvlc_media_player_t > p_mi, int on);
    /**
     * Get the pixel dimensions of a video.<br>
     * \param p_mi media player<br>
     * \param num number of the video (starting from, and most commonly 0)<br>
     * \param px pointer to get the pixel width [OUT]<br>
     * \param py pointer to get the pixel height [OUT]<br>
     * \return 0 on success, -1 if the specified video does not exist<br>
     * Original signature : <code>int libvlc_video_get_size(libvlc_media_player_t*, unsigned, unsigned*, unsigned*)</code><br>
     * <i>native declaration : line 2472</i>
     */
    public static native int libvlc_video_get_size(Pointer<LibvlcLibrary.libvlc_media_player_t > p_mi, int num, Pointer<Integer > px, Pointer<Integer > py);
    /**
     * Get current video height.<br>
     * \deprecated Use libvlc_video_get_size() instead.<br>
     * \param p_mi the media player<br>
     * \return the video pixel height or 0 if not applicable<br>
     * Original signature : <code>int libvlc_video_get_height(libvlc_media_player_t*)</code><br>
     * <i>native declaration : line 2483</i>
     */
    public static native int libvlc_video_get_height(Pointer<LibvlcLibrary.libvlc_media_player_t > p_mi);
    /**
     * Get current video width.<br>
     * \deprecated Use libvlc_video_get_size() instead.<br>
     * \param p_mi the media player<br>
     * \return the video pixel width or 0 if not applicable<br>
     * Original signature : <code>int libvlc_video_get_width(libvlc_media_player_t*)</code><br>
     * <i>native declaration : line 2493</i>
     */
    public static native int libvlc_video_get_width(Pointer<LibvlcLibrary.libvlc_media_player_t > p_mi);
    /**
     * Get the mouse pointer coordinates over a video.<br>
     * Coordinates are expressed in terms of the decoded video resolution,<br>
     * <b>not</b> in terms of pixels on the screen/viewport (to get the latter,<br>
     * you can query your windowing system directly).<br>
     * Either of the coordinates may be negative or larger than the corresponding<br>
     * dimension of the video, if the cursor is outside the rendering area.<br>
     * @warning The coordinates may be out-of-date if the pointer is not located<br>
     * on the video rendering area. LibVLC does not track the pointer if it is<br>
     * outside of the video widget.<br>
     * @note LibVLC does not support multiple pointers (it does of course support<br>
     * multiple input devices sharing the same pointer) at the moment.<br>
     * \param p_mi media player<br>
     * \param num number of the video (starting from, and most commonly 0)<br>
     * \param px pointer to get the abscissa [OUT]<br>
     * \param py pointer to get the ordinate [OUT]<br>
     * \return 0 on success, -1 if the specified video does not exist<br>
     * Original signature : <code>int libvlc_video_get_cursor(libvlc_media_player_t*, unsigned, int*, int*)</code><br>
     * <i>native declaration : line 2518</i>
     */
    public static native int libvlc_video_get_cursor(Pointer<LibvlcLibrary.libvlc_media_player_t > p_mi, int num, Pointer<Integer > px, Pointer<Integer > py);
    /**
     * Get the current video scaling factor.<br>
     * See also libvlc_video_set_scale().<br>
     * \param p_mi the media player<br>
     * \return the currently configured zoom factor, or 0. if the video is set<br>
     * to fit to the output window/drawable automatically.<br>
     * Original signature : <code>float libvlc_video_get_scale(libvlc_media_player_t*)</code><br>
     * <i>native declaration : line 2529</i>
     */
    public static native float libvlc_video_get_scale(Pointer<LibvlcLibrary.libvlc_media_player_t > p_mi);
    /**
     * Set the video scaling factor. That is the ratio of the number of pixels on<br>
     * screen to the number of pixels in the original decoded video in each<br>
     * dimension. Zero is a special value; it will adjust the video to the output<br>
     * window/drawable (in windowed mode) or the entire screen.<br>
     * Note that not all video outputs support scaling.<br>
     * \param p_mi the media player<br>
     * \param f_factor the scaling factor, or zero<br>
     * Original signature : <code>void libvlc_video_set_scale(libvlc_media_player_t*, float)</code><br>
     * <i>native declaration : line 2542</i>
     */
    public static native void libvlc_video_set_scale(Pointer<LibvlcLibrary.libvlc_media_player_t > p_mi, float f_factor);
    /**
     * Get current video aspect ratio.<br>
     * \param p_mi the media player<br>
     * \return the video aspect ratio or NULL if unspecified<br>
     * (the result must be released with free() or libvlc_free()).<br>
     * Original signature : <code>char* libvlc_video_get_aspect_ratio(libvlc_media_player_t*)</code><br>
     * <i>native declaration : line 2551</i>
     */
    public static native Pointer<Byte > libvlc_video_get_aspect_ratio(Pointer<LibvlcLibrary.libvlc_media_player_t > p_mi);
    /**
     * Set new video aspect ratio.<br>
     * \param p_mi the media player<br>
     * \param psz_aspect new video aspect-ratio or NULL to reset to default<br>
     * \note Invalid aspect ratios are ignored.<br>
     * Original signature : <code>void libvlc_video_set_aspect_ratio(libvlc_media_player_t*, const char*)</code><br>
     * <i>native declaration : line 2560</i>
     */
    public static native void libvlc_video_set_aspect_ratio(Pointer<LibvlcLibrary.libvlc_media_player_t > p_mi, Pointer<Byte > psz_aspect);
    /**
     * Get current video subtitle.<br>
     * \param p_mi the media player<br>
     * \return the video subtitle selected, or -1 if none<br>
     * Original signature : <code>int libvlc_video_get_spu(libvlc_media_player_t*)</code><br>
     * <i>native declaration : line 2568</i>
     */
    public static native int libvlc_video_get_spu(Pointer<LibvlcLibrary.libvlc_media_player_t > p_mi);
    /**
     * Get the number of available video subtitles.<br>
     * \param p_mi the media player<br>
     * \return the number of available video subtitles<br>
     * Original signature : <code>int libvlc_video_get_spu_count(libvlc_media_player_t*)</code><br>
     * <i>native declaration : line 2576</i>
     */
    public static native int libvlc_video_get_spu_count(Pointer<LibvlcLibrary.libvlc_media_player_t > p_mi);
    /**
     * Get the description of available video subtitles.<br>
     * \param p_mi the media player<br>
     * \return list containing description of available video subtitles.<br>
     * It must be freed with libvlc_track_description_list_release()<br>
     * Original signature : <code>libvlc_track_description_t* libvlc_video_get_spu_description(libvlc_media_player_t*)</code><br>
     * <i>native declaration : line 2585</i>
     */
    public static native Pointer<libvlc_track_description_t > libvlc_video_get_spu_description(Pointer<LibvlcLibrary.libvlc_media_player_t > p_mi);
    /**
     * Set new video subtitle.<br>
     * \param p_mi the media player<br>
     * \param i_spu video subtitle track to select (i_id from track description)<br>
     * \return 0 on success, -1 if out of range<br>
     * Original signature : <code>int libvlc_video_set_spu(libvlc_media_player_t*, int)</code><br>
     * <i>native declaration : line 2595</i>
     */
    public static native int libvlc_video_set_spu(Pointer<LibvlcLibrary.libvlc_media_player_t > p_mi, int i_spu);
    /**
     * Set new video subtitle file.<br>
     * \param p_mi the media player<br>
     * \param psz_subtitle new video subtitle file<br>
     * \return the success status (boolean)<br>
     * Original signature : <code>int libvlc_video_set_subtitle_file(libvlc_media_player_t*, const char*)</code><br>
     * <i>native declaration : line 2604</i>
     */
    public static native int libvlc_video_set_subtitle_file(Pointer<LibvlcLibrary.libvlc_media_player_t > p_mi, Pointer<Byte > psz_subtitle);
    /**
     * Get the current subtitle delay. Positive values means subtitles are being<br>
     * displayed later, negative values earlier.<br>
     * \param p_mi media player<br>
     * \return time (in microseconds) the display of subtitles is being delayed<br>
     * \version LibVLC 2.0.0 or later<br>
     * Original signature : <code>int64_t libvlc_video_get_spu_delay(libvlc_media_player_t*)</code><br>
     * <i>native declaration : line 2614</i>
     */
    public static native long libvlc_video_get_spu_delay(Pointer<LibvlcLibrary.libvlc_media_player_t > p_mi);
    /**
     * Set the subtitle delay. This affects the timing of when the subtitle will<br>
     * be displayed. Positive values result in subtitles being displayed later,<br>
     * while negative values will result in subtitles being displayed earlier.<br>
     * The subtitle delay will be reset to zero each time the media changes.<br>
     * \param p_mi media player<br>
     * \param i_delay time (in microseconds) the display of subtitles should be delayed<br>
     * \return 0 on success, -1 on error<br>
     * \version LibVLC 2.0.0 or later<br>
     * Original signature : <code>int libvlc_video_set_spu_delay(libvlc_media_player_t*, int64_t)</code><br>
     * <i>native declaration : line 2628</i>
     */
    public static native int libvlc_video_set_spu_delay(Pointer<LibvlcLibrary.libvlc_media_player_t > p_mi, long i_delay);
    /**
     * Get the description of available titles.<br>
     * \param p_mi the media player<br>
     * \return list containing description of available titles.<br>
     * It must be freed with libvlc_track_description_list_release()<br>
     * Original signature : <code>libvlc_track_description_t* libvlc_video_get_title_description(libvlc_media_player_t*)</code><br>
     * <i>native declaration : line 2637</i>
     */
    public static native Pointer<libvlc_track_description_t > libvlc_video_get_title_description(Pointer<LibvlcLibrary.libvlc_media_player_t > p_mi);
    /**
     * Get the description of available chapters for specific title.<br>
     * \param p_mi the media player<br>
     * \param i_title selected title<br>
     * \return list containing description of available chapter for title i_title.<br>
     * It must be freed with libvlc_track_description_list_release()<br>
     * Original signature : <code>libvlc_track_description_t* libvlc_video_get_chapter_description(libvlc_media_player_t*, int)</code><br>
     * <i>native declaration : line 2648</i>
     */
    public static native Pointer<libvlc_track_description_t > libvlc_video_get_chapter_description(Pointer<LibvlcLibrary.libvlc_media_player_t > p_mi, int i_title);
    /**
     * Get current crop filter geometry.<br>
     * \param p_mi the media player<br>
     * \return the crop filter geometry or NULL if unset<br>
     * Original signature : <code>char* libvlc_video_get_crop_geometry(libvlc_media_player_t*)</code><br>
     * <i>native declaration : line 2657</i>
     */
    public static native Pointer<Byte > libvlc_video_get_crop_geometry(Pointer<LibvlcLibrary.libvlc_media_player_t > p_mi);
    /**
     * Set new crop filter geometry.<br>
     * \param p_mi the media player<br>
     * \param psz_geometry new crop filter geometry (NULL to unset)<br>
     * Original signature : <code>void libvlc_video_set_crop_geometry(libvlc_media_player_t*, const char*)</code><br>
     * <i>native declaration : line 2666</i>
     */
    public static native void libvlc_video_set_crop_geometry(Pointer<LibvlcLibrary.libvlc_media_player_t > p_mi, Pointer<Byte > psz_geometry);
    /**
     * Get current teletext page requested.<br>
     * \param p_mi the media player<br>
     * \return the current teletext page requested.<br>
     * Original signature : <code>int libvlc_video_get_teletext(libvlc_media_player_t*)</code><br>
     * <i>native declaration : line 2674</i>
     */
    public static native int libvlc_video_get_teletext(Pointer<LibvlcLibrary.libvlc_media_player_t > p_mi);
    /**
     * Set new teletext page to retrieve.<br>
     * \param p_mi the media player<br>
     * \param i_page teletex page number requested<br>
     * Original signature : <code>void libvlc_video_set_teletext(libvlc_media_player_t*, int)</code><br>
     * <i>native declaration : line 2682</i>
     */
    public static native void libvlc_video_set_teletext(Pointer<LibvlcLibrary.libvlc_media_player_t > p_mi, int i_page);
    /**
     * Toggle teletext transparent status on video output.<br>
     * \param p_mi the media player<br>
     * Original signature : <code>void libvlc_toggle_teletext(libvlc_media_player_t*)</code><br>
     * <i>native declaration : line 2689</i>
     */
    public static native void libvlc_toggle_teletext(Pointer<LibvlcLibrary.libvlc_media_player_t > p_mi);
    /**
     * Get number of available video tracks.<br>
     * \param p_mi media player<br>
     * \return the number of available video tracks (int)<br>
     * Original signature : <code>int libvlc_video_get_track_count(libvlc_media_player_t*)</code><br>
     * <i>native declaration : line 2697</i>
     */
    public static native int libvlc_video_get_track_count(Pointer<LibvlcLibrary.libvlc_media_player_t > p_mi);
    /**
     * Get the description of available video tracks.<br>
     * \param p_mi media player<br>
     * \return list with description of available video tracks, or NULL on error.<br>
     * It must be freed with libvlc_track_description_list_release()<br>
     * Original signature : <code>libvlc_track_description_t* libvlc_video_get_track_description(libvlc_media_player_t*)</code><br>
     * <i>native declaration : line 2706</i>
     */
    public static native Pointer<libvlc_track_description_t > libvlc_video_get_track_description(Pointer<LibvlcLibrary.libvlc_media_player_t > p_mi);
    /**
     * Get current video track.<br>
     * \param p_mi media player<br>
     * \return the video track ID (int) or -1 if no active input<br>
     * Original signature : <code>int libvlc_video_get_track(libvlc_media_player_t*)</code><br>
     * <i>native declaration : line 2715</i>
     */
    public static native int libvlc_video_get_track(Pointer<LibvlcLibrary.libvlc_media_player_t > p_mi);
    /**
     * Set video track.<br>
     * \param p_mi media player<br>
     * \param i_track the track ID (i_id field from track description)<br>
     * \return 0 on success, -1 if out of range<br>
     * Original signature : <code>int libvlc_video_set_track(libvlc_media_player_t*, int)</code><br>
     * <i>native declaration : line 2725</i>
     */
    public static native int libvlc_video_set_track(Pointer<LibvlcLibrary.libvlc_media_player_t > p_mi, int i_track);
    /**
     * Take a snapshot of the current video window.<br>
     * If i_width AND i_height is 0, original size is used.<br>
     * If i_width XOR i_height is 0, original aspect-ratio is preserved.<br>
     * \param p_mi media player instance<br>
     * \param num number of video output (typically 0 for the first/only one)<br>
     * \param psz_filepath the path where to save the screenshot to<br>
     * \param i_width the snapshot's width<br>
     * \param i_height the snapshot's height<br>
     * \return 0 on success, -1 if the video was not found<br>
     * Original signature : <code>int libvlc_video_take_snapshot(libvlc_media_player_t*, unsigned, const char*, unsigned int, unsigned int)</code><br>
     * <i>native declaration : line 2741</i>
     */
    public static native int libvlc_video_take_snapshot(Pointer<LibvlcLibrary.libvlc_media_player_t > p_mi, int num, Pointer<Byte > psz_filepath, int i_width, int i_height);
    /**
     * Enable or disable deinterlace filter<br>
     * \param p_mi libvlc media player<br>
     * \param psz_mode type of deinterlace filter, NULL to disable<br>
     * Original signature : <code>void libvlc_video_set_deinterlace(libvlc_media_player_t*, const char*)</code><br>
     * <i>native declaration : line 2751</i>
     */
    public static native void libvlc_video_set_deinterlace(Pointer<LibvlcLibrary.libvlc_media_player_t > p_mi, Pointer<Byte > psz_mode);
    /**
     * Get an integer marquee option value<br>
     * \param p_mi libvlc media player<br>
     * \param option marq option to get \see libvlc_video_marquee_int_option_t<br>
     * Original signature : <code>int libvlc_video_get_marquee_int(libvlc_media_player_t*, unsigned)</code><br>
     * <i>native declaration : line 2760</i>
     */
    public static native int libvlc_video_get_marquee_int(Pointer<LibvlcLibrary.libvlc_media_player_t > p_mi, int option);
    /**
     * Get a string marquee option value<br>
     * \param p_mi libvlc media player<br>
     * \param option marq option to get \see libvlc_video_marquee_string_option_t<br>
     * Original signature : <code>char* libvlc_video_get_marquee_string(libvlc_media_player_t*, unsigned)</code><br>
     * <i>native declaration : line 2769</i>
     */
    public static native Pointer<Byte > libvlc_video_get_marquee_string(Pointer<LibvlcLibrary.libvlc_media_player_t > p_mi, int option);
    /**
     * Enable, disable or set an integer marquee option<br>
     * Setting libvlc_marquee_Enable has the side effect of enabling (arg !0)<br>
     * or disabling (arg 0) the marq filter.<br>
     * \param p_mi libvlc media player<br>
     * \param option marq option to set \see libvlc_video_marquee_int_option_t<br>
     * \param i_val marq option value<br>
     * Original signature : <code>void libvlc_video_set_marquee_int(libvlc_media_player_t*, unsigned, int)</code><br>
     * <i>native declaration : line 2782</i>
     */
    public static native void libvlc_video_set_marquee_int(Pointer<LibvlcLibrary.libvlc_media_player_t > p_mi, int option, int i_val);
    /**
     * Set a marquee string option<br>
     * \param p_mi libvlc media player<br>
     * \param option marq option to set \see libvlc_video_marquee_string_option_t<br>
     * \param psz_text marq option value<br>
     * Original signature : <code>void libvlc_video_set_marquee_string(libvlc_media_player_t*, unsigned, const char*)</code><br>
     * <i>native declaration : line 2792</i>
     */
    public static native void libvlc_video_set_marquee_string(Pointer<LibvlcLibrary.libvlc_media_player_t > p_mi, int option, Pointer<Byte > psz_text);
    /**
     * Get integer logo option.<br>
     * \param p_mi libvlc media player instance<br>
     * \param option logo option to get, values of libvlc_video_logo_option_t<br>
     * Original signature : <code>int libvlc_video_get_logo_int(libvlc_media_player_t*, unsigned)</code><br>
     * <i>native declaration : line 2813</i>
     */
    public static native int libvlc_video_get_logo_int(Pointer<LibvlcLibrary.libvlc_media_player_t > p_mi, int option);
    /**
     * Set logo option as integer. Options that take a different type value<br>
     * are ignored.<br>
     * Passing libvlc_logo_enable as option value has the side effect of<br>
     * starting (arg !0) or stopping (arg 0) the logo filter.<br>
     * \param p_mi libvlc media player instance<br>
     * \param option logo option to set, values of libvlc_video_logo_option_t<br>
     * \param value logo option value<br>
     * Original signature : <code>void libvlc_video_set_logo_int(libvlc_media_player_t*, unsigned, int)</code><br>
     * <i>native declaration : line 2826</i>
     */
    public static native void libvlc_video_set_logo_int(Pointer<LibvlcLibrary.libvlc_media_player_t > p_mi, int option, int value);
    /**
     * Set logo option as string. Options that take a different type value<br>
     * are ignored.<br>
     * \param p_mi libvlc media player instance<br>
     * \param option logo option to set, values of libvlc_video_logo_option_t<br>
     * \param psz_value logo option value<br>
     * Original signature : <code>void libvlc_video_set_logo_string(libvlc_media_player_t*, unsigned, const char*)</code><br>
     * <i>native declaration : line 2837</i>
     */
    public static native void libvlc_video_set_logo_string(Pointer<LibvlcLibrary.libvlc_media_player_t > p_mi, int option, Pointer<Byte > psz_value);
    /**
     * Get integer adjust option.<br>
     * \param p_mi libvlc media player instance<br>
     * \param option adjust option to get, values of libvlc_video_adjust_option_t<br>
     * \version LibVLC 1.1.1 and later.<br>
     * Original signature : <code>int libvlc_video_get_adjust_int(libvlc_media_player_t*, unsigned)</code><br>
     * <i>native declaration : line 2858</i>
     */
    public static native int libvlc_video_get_adjust_int(Pointer<LibvlcLibrary.libvlc_media_player_t > p_mi, int option);
    /**
     * Set adjust option as integer. Options that take a different type value<br>
     * are ignored.<br>
     * Passing libvlc_adjust_enable as option value has the side effect of<br>
     * starting (arg !0) or stopping (arg 0) the adjust filter.<br>
     * \param p_mi libvlc media player instance<br>
     * \param option adust option to set, values of libvlc_video_adjust_option_t<br>
     * \param value adjust option value<br>
     * \version LibVLC 1.1.1 and later.<br>
     * Original signature : <code>void libvlc_video_set_adjust_int(libvlc_media_player_t*, unsigned, int)</code><br>
     * <i>native declaration : line 2872</i>
     */
    public static native void libvlc_video_set_adjust_int(Pointer<LibvlcLibrary.libvlc_media_player_t > p_mi, int option, int value);
    /**
     * Get float adjust option.<br>
     * \param p_mi libvlc media player instance<br>
     * \param option adjust option to get, values of libvlc_video_adjust_option_t<br>
     * \version LibVLC 1.1.1 and later.<br>
     * Original signature : <code>float libvlc_video_get_adjust_float(libvlc_media_player_t*, unsigned)</code><br>
     * <i>native declaration : line 2882</i>
     */
    public static native float libvlc_video_get_adjust_float(Pointer<LibvlcLibrary.libvlc_media_player_t > p_mi, int option);
    /**
     * Set adjust option as float. Options that take a different type value<br>
     * are ignored.<br>
     * \param p_mi libvlc media player instance<br>
     * \param option adust option to set, values of libvlc_video_adjust_option_t<br>
     * \param value adjust option value<br>
     * \version LibVLC 1.1.1 and later.<br>
     * Original signature : <code>void libvlc_video_set_adjust_float(libvlc_media_player_t*, unsigned, float)</code><br>
     * <i>native declaration : line 2894</i>
     */
    public static native void libvlc_video_set_adjust_float(Pointer<LibvlcLibrary.libvlc_media_player_t > p_mi, int option, float value);
    /**
     * Gets the list of available audio output modules.<br>
     * \param p_instance libvlc instance<br>
     * \return list of available audio outputs. It must be freed with<br>
     *          \see libvlc_audio_output_list_release \see libvlc_audio_output_t .<br>
     *         In case of error, NULL is returned.<br>
     * Original signature : <code>libvlc_audio_output_t* libvlc_audio_output_list_get(libvlc_instance_t*)</code><br>
     * <i>native declaration : line 2939</i>
     */
    public static native Pointer<libvlc_audio_output_t > libvlc_audio_output_list_get(Pointer<LibvlcLibrary.libvlc_instance_t > p_instance);
    /**
     * Frees the list of available audio output modules.<br>
     * \param p_list list with audio outputs for release<br>
     * Original signature : <code>void libvlc_audio_output_list_release(libvlc_audio_output_t*)</code><br>
     * <i>native declaration : line 2948</i>
     */
    public static native void libvlc_audio_output_list_release(Pointer<libvlc_audio_output_t > p_list);
    /**
     * Selects an audio output module.<br>
     * \note Any change will take be effect only after playback is stopped and<br>
     * restarted. Audio output cannot be changed while playing.<br>
     * \param p_mi media player<br>
     * \param psz_name name of audio output,<br>
     *               use psz_name of \see libvlc_audio_output_t<br>
     * \return 0 if function succeded, -1 on error<br>
     * Original signature : <code>int libvlc_audio_output_set(libvlc_media_player_t*, const char*)</code><br>
     * <i>native declaration : line 2960</i>
     */
    public static native int libvlc_audio_output_set(Pointer<LibvlcLibrary.libvlc_media_player_t > p_mi, Pointer<Byte > psz_name);
    /**
     * Backward compatibility stub. Do not use in new code.<br>
     * Use libvlc_audio_output_device_list_get() instead.<br>
     * \return always 0.<br>
     * Original signature : <code>int libvlc_audio_output_device_count(libvlc_instance_t*, const char*)</code><br>
     * <i>native declaration : line 2969</i>
     */
    public static native int libvlc_audio_output_device_count(Pointer<LibvlcLibrary.libvlc_instance_t > libvlc_instance_tPtr1, Pointer<Byte > charPtr1);
    /**
     * Backward compatibility stub. Do not use in new code.<br>
     * Use libvlc_audio_output_device_list_get() instead.<br>
     * \return always NULL.<br>
     * Original signature : <code>char* libvlc_audio_output_device_longname(libvlc_instance_t*, const char*, int)</code><br>
     * <i>native declaration : line 2977</i>
     */
    public static native Pointer<Byte > libvlc_audio_output_device_longname(Pointer<LibvlcLibrary.libvlc_instance_t > libvlc_instance_tPtr1, Pointer<Byte > charPtr1, int int1);
    /**
     * Backward compatibility stub. Do not use in new code.<br>
     * Use libvlc_audio_output_device_list_get() instead.<br>
     * \return always NULL.<br>
     * Original signature : <code>char* libvlc_audio_output_device_id(libvlc_instance_t*, const char*, int)</code><br>
     * <i>native declaration : line 2986</i>
     */
    public static native Pointer<Byte > libvlc_audio_output_device_id(Pointer<LibvlcLibrary.libvlc_instance_t > libvlc_instance_tPtr1, Pointer<Byte > charPtr1, int int1);
    /**
     * Gets a list of potential audio output devices,<br>
     * \see libvlc_audio_output_device_set().<br>
     * \note Not all audio outputs support enumerating devices.<br>
     * The audio output may be functional even if the list is empty (NULL).<br>
     * \note The list may not be exhaustive.<br>
     * \warning Some audio output devices in the list might not actually work in<br>
     * some circumstances. By default, it is recommended to not specify any<br>
     * explicit audio device.<br>
     * \param mp media player<br>
     * \return A NULL-terminated linked list of potential audio output devices.<br>
     * It must be freed with libvlc_audio_output_device_list_release()<br>
     * \version LibVLC 2.2.0 or later.<br>
     * Original signature : <code>libvlc_audio_output_device_t* libvlc_audio_output_device_enum(libvlc_media_player_t*)</code><br>
     * <i>native declaration : line 3006</i>
     */
    public static native Pointer<libvlc_audio_output_device_t > libvlc_audio_output_device_enum(Pointer<LibvlcLibrary.libvlc_media_player_t > mp);
    /**
     * Gets a list of audio output devices for a given audio output module,<br>
     * \see libvlc_audio_output_device_set().<br>
     * \note Not all audio outputs support this. In particular, an empty (NULL)<br>
     * list of devices does <b>not</b> imply that the specified audio output does<br>
     * not work.<br>
     * \note The list might not be exhaustive.<br>
     * \warning Some audio output devices in the list might not actually work in<br>
     * some circumstances. By default, it is recommended to not specify any<br>
     * explicit audio device.<br>
     * \param p_instance libvlc instance<br>
     * \param psz_aout audio output name<br>
     *                 (as returned by libvlc_audio_output_list_get())<br>
     * \return A NULL-terminated linked list of potential audio output devices.<br>
     * It must be freed with libvlc_audio_output_device_list_release()<br>
     * \version LibVLC 2.1.0 or later.<br>
     * Original signature : <code>libvlc_audio_output_device_t* libvlc_audio_output_device_list_get(libvlc_instance_t*, const char*)</code><br>
     * <i>native declaration : line 3030</i>
     */
    public static native Pointer<libvlc_audio_output_device_t > libvlc_audio_output_device_list_get(Pointer<LibvlcLibrary.libvlc_instance_t > p_instance, Pointer<Byte > aout);
    /**
     * Frees a list of available audio output devices.<br>
     * \param p_list list with audio outputs for release<br>
     * \version LibVLC 2.1.0 or later.<br>
     * Original signature : <code>void libvlc_audio_output_device_list_release(libvlc_audio_output_device_t*)</code><br>
     * <i>native declaration : line 3040</i>
     */
    public static native void libvlc_audio_output_device_list_release(Pointer<libvlc_audio_output_device_t > p_list);
    /**
     * Configures an explicit audio output device.<br>
     * If the module paramater is NULL, audio output will be moved to the device<br>
     * specified by the device identifier string immediately. This is the<br>
     * recommended usage.<br>
     * A list of adequate potential device strings can be obtained with<br>
     * libvlc_audio_output_device_enum().<br>
     * However passing NULL is supported in LibVLC version 2.2.0 and later only;<br>
     * in earlier versions, this function would have no effects when the module<br>
     * parameter was NULL.<br>
     * If the module parameter is not NULL, the device parameter of the<br>
     * corresponding audio output, if it exists, will be set to the specified<br>
     * string. Note that some audio output modules do not have such a parameter<br>
     * (notably MMDevice and PulseAudio).<br>
     * A list of adequate potential device strings can be obtained with<br>
     * libvlc_audio_output_device_list_get().<br>
     * \note This function does not select the specified audio output plugin.<br>
     * libvlc_audio_output_set() is used for that purpose.<br>
     * \warning The syntax for the device parameter depends on the audio output.<br>
     * Some audio output modules require further parameters (e.g. a channels map<br>
     * in the case of ALSA).<br>
     * \param mp media player<br>
     * \param module If NULL, current audio output module.<br>
     *               if non-NULL, name of audio output module<br>
     * (\see libvlc_audio_output_t)<br>
     * \param device_id device identifier string<br>
     * \return Nothing. Errors are ignored (this is a design bug).<br>
     * Original signature : <code>void libvlc_audio_output_device_set(libvlc_media_player_t*, const char*, const char*)</code><br>
     * <i>native declaration : line 3080</i>
     */
    public static native void libvlc_audio_output_device_set(Pointer<LibvlcLibrary.libvlc_media_player_t > mp, Pointer<Byte > module, Pointer<Byte > device_id);
    /**
     * Get the current audio output device identifier.<br>
     * This complements libvlc_audio_output_device_set().<br>
     * \warning The initial value for the current audio output device identifier<br>
     * may not be set or may be some unknown value. A LibVLC application should<br>
     * compare this value against the known device identifiers (e.g. those that<br>
     * were previously retrieved by a call to libvlc_audio_output_device_enum or<br>
     * libvlc_audio_output_device_list_get) to find the current audio output device.<br>
     * It is possible that the selected audio output device changes (an external<br>
     * change) without a call to libvlc_audio_output_device_set. That may make this<br>
     * method unsuitable to use if a LibVLC application is attempting to track<br>
     * dynamic audio device changes as they happen.<br>
     * \param mp media player<br>
     * \return the current audio output device identifier<br>
     *         NULL if no device is selected or in case of error<br>
     *         (the result must be released with free() or libvlc_free()).<br>
     * \version LibVLC 3.0.0 or later.<br>
     * Original signature : <code>char* libvlc_audio_output_device_get(libvlc_media_player_t*)</code><br>
     * <i>native declaration : line 3106</i>
     */
    public static native Pointer<Byte > libvlc_audio_output_device_get(Pointer<LibvlcLibrary.libvlc_media_player_t > mp);
    /**
     * Stub for backward compatibility.<br>
     * \return always -1.<br>
     * Original signature : <code>int libvlc_audio_output_get_device_type(libvlc_media_player_t*)</code><br>
     * <i>native declaration : line 3113</i>
     */
    public static native int libvlc_audio_output_get_device_type(Pointer<LibvlcLibrary.libvlc_media_player_t > p_mi);
    /**
     * Stub for backward compatibility.<br>
     * Original signature : <code>void libvlc_audio_output_set_device_type(libvlc_media_player_t*, int)</code><br>
     * <i>native declaration : line 3119</i>
     */
    public static native void libvlc_audio_output_set_device_type(Pointer<LibvlcLibrary.libvlc_media_player_t > libvlc_media_player_tPtr1, int int1);
    /**
     * Toggle mute status.<br>
     * \param p_mi media player<br>
     * \warning Toggling mute atomically is not always possible: On some platforms,<br>
     * other processes can mute the VLC audio playback stream asynchronously. Thus,<br>
     * there is a small race condition where toggling will not work.<br>
     * See also the limitations of libvlc_audio_set_mute().<br>
     * Original signature : <code>void libvlc_audio_toggle_mute(libvlc_media_player_t*)</code><br>
     * <i>native declaration : line 3132</i>
     */
    public static native void libvlc_audio_toggle_mute(Pointer<LibvlcLibrary.libvlc_media_player_t > p_mi);
    /**
     * Get current mute status.<br>
     * \param p_mi media player<br>
     * \return the mute status (boolean) if defined, -1 if undefined/unapplicable<br>
     * Original signature : <code>int libvlc_audio_get_mute(libvlc_media_player_t*)</code><br>
     * <i>native declaration : line 3140</i>
     */
    public static native int libvlc_audio_get_mute(Pointer<LibvlcLibrary.libvlc_media_player_t > p_mi);
    /**
     * Set mute status.<br>
     * \param p_mi media player<br>
     * \param status If status is true then mute, otherwise unmute<br>
     * \warning This function does not always work. If there are no active audio<br>
     * playback stream, the mute status might not be available. If digital<br>
     * pass-through (S/PDIF, HDMI...) is in use, muting may be unapplicable. Also<br>
     * some audio output plugins do not support muting at all.<br>
     * \note To force silent playback, disable all audio tracks. This is more<br>
     * efficient and reliable than mute.<br>
     * Original signature : <code>void libvlc_audio_set_mute(libvlc_media_player_t*, int)</code><br>
     * <i>native declaration : line 3154</i>
     */
    public static native void libvlc_audio_set_mute(Pointer<LibvlcLibrary.libvlc_media_player_t > p_mi, int status);
    /**
     * Get current software audio volume.<br>
     * \param p_mi media player<br>
     * \return the software volume in percents<br>
     * (0 = mute, 100 = nominal / 0dB)<br>
     * Original signature : <code>int libvlc_audio_get_volume(libvlc_media_player_t*)</code><br>
     * <i>native declaration : line 3163</i>
     */
    public static native int libvlc_audio_get_volume(Pointer<LibvlcLibrary.libvlc_media_player_t > p_mi);
    /**
     * Set current software audio volume.<br>
     * \param p_mi media player<br>
     * \param i_volume the volume in percents (0 = mute, 100 = 0dB)<br>
     * \return 0 if the volume was set, -1 if it was out of range<br>
     * Original signature : <code>int libvlc_audio_set_volume(libvlc_media_player_t*, int)</code><br>
     * <i>native declaration : line 3172</i>
     */
    public static native int libvlc_audio_set_volume(Pointer<LibvlcLibrary.libvlc_media_player_t > p_mi, int i_volume);
    /**
     * Get number of available audio tracks.<br>
     * \param p_mi media player<br>
     * \return the number of available audio tracks (int), or -1 if unavailable<br>
     * Original signature : <code>int libvlc_audio_get_track_count(libvlc_media_player_t*)</code><br>
     * <i>native declaration : line 3180</i>
     */
    public static native int libvlc_audio_get_track_count(Pointer<LibvlcLibrary.libvlc_media_player_t > p_mi);
    /**
     * Get the description of available audio tracks.<br>
     * \param p_mi media player<br>
     * \return list with description of available audio tracks, or NULL.<br>
     * It must be freed with libvlc_track_description_list_release()<br>
     * Original signature : <code>libvlc_track_description_t* libvlc_audio_get_track_description(libvlc_media_player_t*)</code><br>
     * <i>native declaration : line 3189</i>
     */
    public static native Pointer<libvlc_track_description_t > libvlc_audio_get_track_description(Pointer<LibvlcLibrary.libvlc_media_player_t > p_mi);
    /**
     * Get current audio track.<br>
     * \param p_mi media player<br>
     * \return the audio track ID or -1 if no active input.<br>
     * Original signature : <code>int libvlc_audio_get_track(libvlc_media_player_t*)</code><br>
     * <i>native declaration : line 3198</i>
     */
    public static native int libvlc_audio_get_track(Pointer<LibvlcLibrary.libvlc_media_player_t > p_mi);
    /**
     * Set current audio track.<br>
     * \param p_mi media player<br>
     * \param i_track the track ID (i_id field from track description)<br>
     * \return 0 on success, -1 on error<br>
     * Original signature : <code>int libvlc_audio_set_track(libvlc_media_player_t*, int)</code><br>
     * <i>native declaration : line 3207</i>
     */
    public static native int libvlc_audio_set_track(Pointer<LibvlcLibrary.libvlc_media_player_t > p_mi, int i_track);
    /**
     * Get current audio channel.<br>
     * \param p_mi media player<br>
     * \return the audio channel \see libvlc_audio_output_channel_t<br>
     * Original signature : <code>int libvlc_audio_get_channel(libvlc_media_player_t*)</code><br>
     * <i>native declaration : line 3215</i>
     */
    public static native int libvlc_audio_get_channel(Pointer<LibvlcLibrary.libvlc_media_player_t > p_mi);
    /**
     * Set current audio channel.<br>
     * \param p_mi media player<br>
     * \param channel the audio channel, \see libvlc_audio_output_channel_t<br>
     * \return 0 on success, -1 on error<br>
     * Original signature : <code>int libvlc_audio_set_channel(libvlc_media_player_t*, int)</code><br>
     * <i>native declaration : line 3224</i>
     */
    public static native int libvlc_audio_set_channel(Pointer<LibvlcLibrary.libvlc_media_player_t > p_mi, int channel);
    /**
     * Get current audio delay.<br>
     * \param p_mi media player<br>
     * \return the audio delay (microseconds)<br>
     * \version LibVLC 1.1.1 or later<br>
     * Original signature : <code>int64_t libvlc_audio_get_delay(libvlc_media_player_t*)</code><br>
     * <i>native declaration : line 3233</i>
     */
    public static native long libvlc_audio_get_delay(Pointer<LibvlcLibrary.libvlc_media_player_t > p_mi);
    /**
     * Set current audio delay. The audio delay will be reset to zero each time the media changes.<br>
     * \param p_mi media player<br>
     * \param i_delay the audio delay (microseconds)<br>
     * \return 0 on success, -1 on error<br>
     * \version LibVLC 1.1.1 or later<br>
     * Original signature : <code>int libvlc_audio_set_delay(libvlc_media_player_t*, int64_t)</code><br>
     * <i>native declaration : line 3243</i>
     */
    public static native int libvlc_audio_set_delay(Pointer<LibvlcLibrary.libvlc_media_player_t > p_mi, long i_delay);
    /**
     * Get the number of equalizer presets.<br>
     * \return number of presets<br>
     * \version LibVLC 2.2.0 or later<br>
     * Original signature : <code>int libvlc_audio_equalizer_get_preset_count()</code><br>
     * <i>native declaration : line 3251</i>
     */
    public static native int libvlc_audio_equalizer_get_preset_count();
    /**
     * Get the name of a particular equalizer preset.<br>
     * This name can be used, for example, to prepare a preset label or menu in a user<br>
     * interface.<br>
     * \param u_index index of the preset, counting from zero<br>
     * \return preset name, or NULL if there is no such preset<br>
     * \version LibVLC 2.2.0 or later<br>
     * Original signature : <code>char* libvlc_audio_equalizer_get_preset_name(unsigned)</code><br>
     * <i>native declaration : line 3263</i>
     */
    public static native Pointer<Byte > libvlc_audio_equalizer_get_preset_name(int u_index);
    /**
     * Get the number of distinct frequency bands for an equalizer.<br>
     * \return number of frequency bands<br>
     * \version LibVLC 2.2.0 or later<br>
     * Original signature : <code>int libvlc_audio_equalizer_get_band_count()</code><br>
     * <i>native declaration : line 3271</i>
     */
    public static native int libvlc_audio_equalizer_get_band_count();
    /**
     * Get a particular equalizer band frequency.<br>
     * This value can be used, for example, to create a label for an equalizer band control<br>
     * in a user interface.<br>
     * \param u_index index of the band, counting from zero<br>
     * \return equalizer band frequency (Hz), or -1 if there is no such band<br>
     * \version LibVLC 2.2.0 or later<br>
     * Original signature : <code>float libvlc_audio_equalizer_get_band_frequency(unsigned)</code><br>
     * <i>native declaration : line 3283</i>
     */
    public static native float libvlc_audio_equalizer_get_band_frequency(int u_index);
    /**
     * Create a new default equalizer, with all frequency values zeroed.<br>
     * The new equalizer can subsequently be applied to a media player by invoking<br>
     * libvlc_media_player_set_equalizer().<br>
     * The returned handle should be freed via libvlc_audio_equalizer_release() when<br>
     * it is no longer needed.<br>
     * \return opaque equalizer handle, or NULL on error<br>
     * \version LibVLC 2.2.0 or later<br>
     * Original signature : <code>libvlc_equalizer_t* libvlc_audio_equalizer_new()</code><br>
     * <i>native declaration : line 3297</i>
     */
    public static native Pointer<LibvlcLibrary.libvlc_equalizer_t > libvlc_audio_equalizer_new();
    /**
     * Create a new equalizer, with initial frequency values copied from an existing<br>
     * preset.<br>
     * The new equalizer can subsequently be applied to a media player by invoking<br>
     * libvlc_media_player_set_equalizer().<br>
     * The returned handle should be freed via libvlc_audio_equalizer_release() when<br>
     * it is no longer needed.<br>
     * \param u_index index of the preset, counting from zero<br>
     * \return opaque equalizer handle, or NULL on error<br>
     * \version LibVLC 2.2.0 or later<br>
     * Original signature : <code>libvlc_equalizer_t* libvlc_audio_equalizer_new_from_preset(unsigned)</code><br>
     * <i>native declaration : line 3313</i>
     */
    public static native Pointer<LibvlcLibrary.libvlc_equalizer_t > libvlc_audio_equalizer_new_from_preset(int u_index);
    /**
     * Release a previously created equalizer instance.<br>
     * The equalizer was previously created by using libvlc_audio_equalizer_new() or<br>
     * libvlc_audio_equalizer_new_from_preset().<br>
     * It is safe to invoke this method with a NULL p_equalizer parameter for no effect.<br>
     * \param p_equalizer opaque equalizer handle, or NULL<br>
     * \version LibVLC 2.2.0 or later<br>
     * Original signature : <code>void libvlc_audio_equalizer_release(libvlc_equalizer_t*)</code><br>
     * <i>native declaration : line 3326</i>
     */
    public static native void libvlc_audio_equalizer_release(Pointer<LibvlcLibrary.libvlc_equalizer_t > p_equalizer);
    /**
     * Set a new pre-amplification value for an equalizer.<br>
     * The new equalizer settings are subsequently applied to a media player by invoking<br>
     * libvlc_media_player_set_equalizer().<br>
     * The supplied amplification value will be clamped to the -20.0 to +20.0 range.<br>
     * \param p_equalizer valid equalizer handle, must not be NULL<br>
     * \param f_preamp preamp value (-20.0 to 20.0 Hz)<br>
     * \return zero on success, -1 on error<br>
     * \version LibVLC 2.2.0 or later<br>
     * Original signature : <code>int libvlc_audio_equalizer_set_preamp(libvlc_equalizer_t*, float)</code><br>
     * <i>native declaration : line 3341</i>
     */
    public static native int libvlc_audio_equalizer_set_preamp(Pointer<LibvlcLibrary.libvlc_equalizer_t > p_equalizer, float f_preamp);
    /**
     * Get the current pre-amplification value from an equalizer.<br>
     * \param p_equalizer valid equalizer handle, must not be NULL<br>
     * \return preamp value (Hz)<br>
     * \version LibVLC 2.2.0 or later<br>
     * Original signature : <code>float libvlc_audio_equalizer_get_preamp(libvlc_equalizer_t*)</code><br>
     * <i>native declaration : line 3350</i>
     */
    public static native float libvlc_audio_equalizer_get_preamp(Pointer<LibvlcLibrary.libvlc_equalizer_t > p_equalizer);
    /**
     * Set a new amplification value for a particular equalizer frequency band.<br>
     * The new equalizer settings are subsequently applied to a media player by invoking<br>
     * libvlc_media_player_set_equalizer().<br>
     * The supplied amplification value will be clamped to the -20.0 to +20.0 range.<br>
     * \param p_equalizer valid equalizer handle, must not be NULL<br>
     * \param f_amp amplification value (-20.0 to 20.0 Hz)<br>
     * \param u_band index, counting from zero, of the frequency band to set<br>
     * \return zero on success, -1 on error<br>
     * \version LibVLC 2.2.0 or later<br>
     * Original signature : <code>int libvlc_audio_equalizer_set_amp_at_index(libvlc_equalizer_t*, float, unsigned)</code><br>
     * <i>native declaration : line 3366</i>
     */
    public static native int libvlc_audio_equalizer_set_amp_at_index(Pointer<LibvlcLibrary.libvlc_equalizer_t > p_equalizer, float f_amp, int u_band);
    /**
     * Get the amplification value for a particular equalizer frequency band.<br>
     * \param p_equalizer valid equalizer handle, must not be NULL<br>
     * \param u_band index, counting from zero, of the frequency band to get<br>
     * \return amplification value (Hz); NaN if there is no such frequency band<br>
     * \version LibVLC 2.2.0 or later<br>
     * Original signature : <code>float libvlc_audio_equalizer_get_amp_at_index(libvlc_equalizer_t*, unsigned)</code><br>
     * <i>native declaration : line 3376</i>
     */
    public static native float libvlc_audio_equalizer_get_amp_at_index(Pointer<LibvlcLibrary.libvlc_equalizer_t > p_equalizer, int u_band);
    /**
     * Apply new equalizer settings to a media player.<br>
     * The equalizer is first created by invoking libvlc_audio_equalizer_new() or<br>
     * libvlc_audio_equalizer_new_from_preset().<br>
     * It is possible to apply new equalizer settings to a media player whether the media<br>
     * player is currently playing media or not.<br>
     * Invoking this method will immediately apply the new equalizer settings to the audio<br>
     * output of the currently playing media if there is any.<br>
     * If there is no currently playing media, the new equalizer settings will be applied<br>
     * later if and when new media is played.<br>
     * Equalizer settings will automatically be applied to subsequently played media.<br>
     * To disable the equalizer for a media player invoke this method passing NULL for the<br>
     * p_equalizer parameter.<br>
     * The media player does not keep a reference to the supplied equalizer so it is safe<br>
     * for an application to release the equalizer reference any time after this method<br>
     * returns.<br>
     * \param p_mi opaque media player handle<br>
     * \param p_equalizer opaque equalizer handle, or NULL to disable the equalizer for this media player<br>
     * \return zero on success, -1 on error<br>
     * \version LibVLC 2.2.0 or later<br>
     * Original signature : <code>int libvlc_media_player_set_equalizer(libvlc_media_player_t*, libvlc_equalizer_t*)</code><br>
     * <i>native declaration : line 3407</i>
     */
    public static native int libvlc_media_player_set_equalizer(Pointer<LibvlcLibrary.libvlc_media_player_t > p_mi, Pointer<LibvlcLibrary.libvlc_equalizer_t > p_equalizer);
    /**
     * Create an empty media list.<br>
     * \param p_instance libvlc instance<br>
     * \return empty media list, or NULL on error<br>
     * Original signature : <code>libvlc_media_list_t* libvlc_media_list_new(libvlc_instance_t*)</code><br>
     * <i>native declaration : line 3467</i>
     */
    public static native Pointer<LibvlcLibrary.libvlc_media_list_t > libvlc_media_list_new(Pointer<LibvlcLibrary.libvlc_instance_t > p_instance);
    /**
     * Release media list created with libvlc_media_list_new().<br>
     * \param p_ml a media list created with libvlc_media_list_new()<br>
     * Original signature : <code>void libvlc_media_list_release(libvlc_media_list_t*)</code><br>
     * <i>native declaration : line 3475</i>
     */
    public static native void libvlc_media_list_release(Pointer<LibvlcLibrary.libvlc_media_list_t > p_ml);
    /**
     * Retain reference to a media list<br>
     * \param p_ml a media list created with libvlc_media_list_new()<br>
     * Original signature : <code>void libvlc_media_list_retain(libvlc_media_list_t*)</code><br>
     * <i>native declaration : line 3483</i>
     */
    public static native void libvlc_media_list_retain(Pointer<LibvlcLibrary.libvlc_media_list_t > p_ml);
    /**
     * Original signature : <code>int libvlc_media_list_add_file_content(libvlc_media_list_t*, const char*)</code><br>
     * <i>native declaration : line 3486</i>
     */
    public static native int libvlc_media_list_add_file_content(Pointer<LibvlcLibrary.libvlc_media_list_t > p_ml, Pointer<Byte > psz_uri);
    /**
     * Associate media instance with this media list instance.<br>
     * If another media instance was present it will be released.<br>
     * The libvlc_media_list_lock should NOT be held upon entering this function.<br>
     * \param p_ml a media list instance<br>
     * \param p_md media instance to add<br>
     * Original signature : <code>void libvlc_media_list_set_media(libvlc_media_list_t*, libvlc_media_t*)</code><br>
     * <i>native declaration : line 3498</i>
     */
    public static native void libvlc_media_list_set_media(Pointer<LibvlcLibrary.libvlc_media_list_t > p_ml, Pointer<LibvlcLibrary.libvlc_media_t > p_md);
    /**
     * Get media instance from this media list instance. This action will increase<br>
     * the refcount on the media instance.<br>
     * The libvlc_media_list_lock should NOT be held upon entering this function.<br>
     * \param p_ml a media list instance<br>
     * \return media instance<br>
     * Original signature : <code>libvlc_media_t* libvlc_media_list_media(libvlc_media_list_t*)</code><br>
     * <i>native declaration : line 3509</i>
     */
    public static native Pointer<LibvlcLibrary.libvlc_media_t > libvlc_media_list_media(Pointer<LibvlcLibrary.libvlc_media_list_t > p_ml);
    /**
     * Add media instance to media list<br>
     * The libvlc_media_list_lock should be held upon entering this function.<br>
     * \param p_ml a media list instance<br>
     * \param p_md a media instance<br>
     * \return 0 on success, -1 if the media list is read-only<br>
     * Original signature : <code>int libvlc_media_list_add_media(libvlc_media_list_t*, libvlc_media_t*)</code><br>
     * <i>native declaration : line 3520</i>
     */
    public static native int libvlc_media_list_add_media(Pointer<LibvlcLibrary.libvlc_media_list_t > p_ml, Pointer<LibvlcLibrary.libvlc_media_t > p_md);
    /**
     * Insert media instance in media list on a position<br>
     * The libvlc_media_list_lock should be held upon entering this function.<br>
     * \param p_ml a media list instance<br>
     * \param p_md a media instance<br>
     * \param i_pos position in array where to insert<br>
     * \return 0 on success, -1 if the media list is read-only<br>
     * Original signature : <code>int libvlc_media_list_insert_media(libvlc_media_list_t*, libvlc_media_t*, int)</code><br>
     * <i>native declaration : line 3532</i>
     */
    public static native int libvlc_media_list_insert_media(Pointer<LibvlcLibrary.libvlc_media_list_t > p_ml, Pointer<LibvlcLibrary.libvlc_media_t > p_md, int i_pos);
    /**
     * Remove media instance from media list on a position<br>
     * The libvlc_media_list_lock should be held upon entering this function.<br>
     * \param p_ml a media list instance<br>
     * \param i_pos position in array where to insert<br>
     * \return 0 on success, -1 if the list is read-only or the item was not found<br>
     * Original signature : <code>int libvlc_media_list_remove_index(libvlc_media_list_t*, int)</code><br>
     * <i>native declaration : line 3544</i>
     */
    public static native int libvlc_media_list_remove_index(Pointer<LibvlcLibrary.libvlc_media_list_t > p_ml, int i_pos);
    /**
     * Get count on media list items<br>
     * The libvlc_media_list_lock should be held upon entering this function.<br>
     * \param p_ml a media list instance<br>
     * \return number of items in media list<br>
     * Original signature : <code>int libvlc_media_list_count(libvlc_media_list_t*)</code><br>
     * <i>native declaration : line 3554</i>
     */
    public static native int libvlc_media_list_count(Pointer<LibvlcLibrary.libvlc_media_list_t > p_ml);
    /**
     * List media instance in media list at a position<br>
     * The libvlc_media_list_lock should be held upon entering this function.<br>
     * \param p_ml a media list instance<br>
     * \param i_pos position in array where to insert<br>
     * \return media instance at position i_pos, or NULL if not found.<br>
     * In case of success, libvlc_media_retain() is called to increase the refcount<br>
     * on the media.<br>
     * Original signature : <code>libvlc_media_t* libvlc_media_list_item_at_index(libvlc_media_list_t*, int)</code><br>
     * <i>native declaration : line 3567</i>
     */
    public static native Pointer<LibvlcLibrary.libvlc_media_t > libvlc_media_list_item_at_index(Pointer<LibvlcLibrary.libvlc_media_list_t > p_ml, int i_pos);
    /**
     * Find index position of List media instance in media list.<br>
     * Warning: the function will return the first matched position.<br>
     * The libvlc_media_list_lock should be held upon entering this function.<br>
     * \param p_ml a media list instance<br>
     * \param p_md media instance<br>
     * \return position of media instance or -1 if media not found<br>
     * Original signature : <code>int libvlc_media_list_index_of_item(libvlc_media_list_t*, libvlc_media_t*)</code><br>
     * <i>native declaration : line 3578</i>
     */
    public static native int libvlc_media_list_index_of_item(Pointer<LibvlcLibrary.libvlc_media_list_t > p_ml, Pointer<LibvlcLibrary.libvlc_media_t > p_md);
    /**
     * This indicates if this media list is read-only from a user point of view<br>
     * \param p_ml media list instance<br>
     * \return 1 on readonly, 0 on readwrite<br>
     * \libvlc_return_bool<br>
     * Original signature : <code>int libvlc_media_list_is_readonly(libvlc_media_list_t*)</code><br>
     * <i>native declaration : line 3590</i>
     */
    public static native int libvlc_media_list_is_readonly(Pointer<LibvlcLibrary.libvlc_media_list_t > p_ml);
    /**
     * Get lock on media list items<br>
     * \param p_ml a media list instance<br>
     * Original signature : <code>void libvlc_media_list_lock(libvlc_media_list_t*)</code><br>
     * <i>native declaration : line 3598</i>
     */
    public static native void libvlc_media_list_lock(Pointer<LibvlcLibrary.libvlc_media_list_t > p_ml);
    /**
     * Release lock on media list items<br>
     * The libvlc_media_list_lock should be held upon entering this function.<br>
     * \param p_ml a media list instance<br>
     * Original signature : <code>void libvlc_media_list_unlock(libvlc_media_list_t*)</code><br>
     * <i>native declaration : line 3607</i>
     */
    public static native void libvlc_media_list_unlock(Pointer<LibvlcLibrary.libvlc_media_list_t > p_ml);
    /**
     * Get libvlc_event_manager from this media list instance.<br>
     * The p_event_manager is immutable, so you don't have to hold the lock<br>
     * \param p_ml a media list instance<br>
     * \return libvlc_event_manager<br>
     * Original signature : <code>libvlc_event_manager_t* libvlc_media_list_event_manager(libvlc_media_list_t*)</code><br>
     * <i>native declaration : line 3617</i>
     */
    public static native Pointer<LibvlcLibrary.libvlc_event_manager_t > libvlc_media_list_event_manager(Pointer<LibvlcLibrary.libvlc_media_list_t > p_ml);
    /**
     * Create new media_list_player.<br>
     * \param p_instance libvlc instance<br>
     * \return media list player instance or NULL on error<br>
     * Original signature : <code>libvlc_media_list_player_t* libvlc_media_list_player_new(libvlc_instance_t*)</code><br>
     * <i>native declaration : line 3693</i>
     */
    public static native Pointer<LibvlcLibrary.libvlc_media_list_player_t > libvlc_media_list_player_new(Pointer<LibvlcLibrary.libvlc_instance_t > p_instance);
    /**
     * Release a media_list_player after use<br>
     * Decrement the reference count of a media player object. If the<br>
     * reference count is 0, then libvlc_media_list_player_release() will<br>
     * release the media player object. If the media player object<br>
     * has been released, then it should not be used again.<br>
     * \param p_mlp media list player instance<br>
     * Original signature : <code>void libvlc_media_list_player_release(libvlc_media_list_player_t*)</code><br>
     * <i>native declaration : line 3705</i>
     */
    public static native void libvlc_media_list_player_release(Pointer<LibvlcLibrary.libvlc_media_list_player_t > p_mlp);
    /**
     * Retain a reference to a media player list object. Use<br>
     * libvlc_media_list_player_release() to decrement reference count.<br>
     * \param p_mlp media player list object<br>
     * Original signature : <code>void libvlc_media_list_player_retain(libvlc_media_list_player_t*)</code><br>
     * <i>native declaration : line 3714</i>
     */
    public static native void libvlc_media_list_player_retain(Pointer<LibvlcLibrary.libvlc_media_list_player_t > p_mlp);
    /**
     * Return the event manager of this media_list_player.<br>
     * \param p_mlp media list player instance<br>
     * \return the event manager<br>
     * Original signature : <code>libvlc_event_manager_t* libvlc_media_list_player_event_manager(libvlc_media_list_player_t*)</code><br>
     * <i>native declaration : line 3723</i>
     */
    public static native Pointer<LibvlcLibrary.libvlc_event_manager_t > libvlc_media_list_player_event_manager(Pointer<LibvlcLibrary.libvlc_media_list_player_t > p_mlp);
    /**
     * Replace media player in media_list_player with this instance.<br>
     * \param p_mlp media list player instance<br>
     * \param p_mi media player instance<br>
     * Original signature : <code>void libvlc_media_list_player_set_media_player(libvlc_media_list_player_t*, libvlc_media_player_t*)</code><br>
     * <i>native declaration : line 3732</i>
     */
    public static native void libvlc_media_list_player_set_media_player(Pointer<LibvlcLibrary.libvlc_media_list_player_t > p_mlp, Pointer<LibvlcLibrary.libvlc_media_player_t > p_mi);
    /**
     * Set the media list associated with the player<br>
     * \param p_mlp media list player instance<br>
     * \param p_mlist list of media<br>
     * Original signature : <code>void libvlc_media_list_player_set_media_list(libvlc_media_list_player_t*, libvlc_media_list_t*)</code><br>
     * <i>native declaration : line 3743</i>
     */
    public static native void libvlc_media_list_player_set_media_list(Pointer<LibvlcLibrary.libvlc_media_list_player_t > p_mlp, Pointer<LibvlcLibrary.libvlc_media_list_t > p_mlist);
    /**
     * Play media list<br>
     * \param p_mlp media list player instance<br>
     * Original signature : <code>void libvlc_media_list_player_play(libvlc_media_list_player_t*)</code><br>
     * <i>native declaration : line 3754</i>
     */
    public static native void libvlc_media_list_player_play(Pointer<LibvlcLibrary.libvlc_media_list_player_t > p_mlp);
    /**
     * Toggle pause (or resume) media list<br>
     * \param p_mlp media list player instance<br>
     * Original signature : <code>void libvlc_media_list_player_pause(libvlc_media_list_player_t*)</code><br>
     * <i>native declaration : line 3762</i>
     */
    public static native void libvlc_media_list_player_pause(Pointer<LibvlcLibrary.libvlc_media_list_player_t > p_mlp);
    /**
     * Is media list playing?<br>
     * \param p_mlp media list player instance<br>
     * \return true for playing and false for not playing<br>
     * \libvlc_return_bool<br>
     * Original signature : <code>int libvlc_media_list_player_is_playing(libvlc_media_list_player_t*)</code><br>
     * <i>native declaration : line 3772</i>
     */
    public static native int libvlc_media_list_player_is_playing(Pointer<LibvlcLibrary.libvlc_media_list_player_t > p_mlp);
    /**
     * Get current libvlc_state of media list player<br>
     * \param p_mlp media list player instance<br>
     * \return libvlc_state_t for media list player<br>
     * Original signature : <code>libvlc_state_t libvlc_media_list_player_get_state(libvlc_media_list_player_t*)</code><br>
     * <i>native declaration : line 3781</i>
     */
    public static native IntValuedEnum<LibvlcLibrary.libvlc_state_t > libvlc_media_list_player_get_state(Pointer<LibvlcLibrary.libvlc_media_list_player_t > p_mlp);
    /**
     * Play media list item at position index<br>
     * \param p_mlp media list player instance<br>
     * \param i_index index in media list to play<br>
     * \return 0 upon success -1 if the item wasn't found<br>
     * Original signature : <code>int libvlc_media_list_player_play_item_at_index(libvlc_media_list_player_t*, int)</code><br>
     * <i>native declaration : line 3792</i>
     */
    public static native int libvlc_media_list_player_play_item_at_index(Pointer<LibvlcLibrary.libvlc_media_list_player_t > p_mlp, int i_index);
    /**
     * Play the given media item<br>
     * \param p_mlp media list player instance<br>
     * \param p_md the media instance<br>
     * \return 0 upon success, -1 if the media is not part of the media list<br>
     * Original signature : <code>int libvlc_media_list_player_play_item(libvlc_media_list_player_t*, libvlc_media_t*)</code><br>
     * <i>native declaration : line 3803</i>
     */
    public static native int libvlc_media_list_player_play_item(Pointer<LibvlcLibrary.libvlc_media_list_player_t > p_mlp, Pointer<LibvlcLibrary.libvlc_media_t > p_md);
    /**
     * Stop playing media list<br>
     * \param p_mlp media list player instance<br>
     * Original signature : <code>void libvlc_media_list_player_stop(libvlc_media_list_player_t*)</code><br>
     * <i>native declaration : line 3811</i>
     */
    public static native void libvlc_media_list_player_stop(Pointer<LibvlcLibrary.libvlc_media_list_player_t > p_mlp);
    /**
     * Play next item from media list<br>
     * \param p_mlp media list player instance<br>
     * \return 0 upon success -1 if there is no next item<br>
     * Original signature : <code>int libvlc_media_list_player_next(libvlc_media_list_player_t*)</code><br>
     * <i>native declaration : line 3821</i>
     */
    public static native int libvlc_media_list_player_next(Pointer<LibvlcLibrary.libvlc_media_list_player_t > p_mlp);
    /**
     * Play previous item from media list<br>
     * \param p_mlp media list player instance<br>
     * \return 0 upon success -1 if there is no previous item<br>
     * Original signature : <code>int libvlc_media_list_player_previous(libvlc_media_list_player_t*)</code><br>
     * <i>native declaration : line 3830</i>
     */
    public static native int libvlc_media_list_player_previous(Pointer<LibvlcLibrary.libvlc_media_list_player_t > p_mlp);
    /**
     * Sets the playback mode for the playlist<br>
     * \param p_mlp media list player instance<br>
     * \param e_mode playback mode specification<br>
     * Original signature : <code>void libvlc_media_list_player_set_playback_mode(libvlc_media_list_player_t*, libvlc_playback_mode_t)</code><br>
     * <i>native declaration : line 3841</i>
     */
    public static native void libvlc_media_list_player_set_playback_mode(Pointer<LibvlcLibrary.libvlc_media_list_player_t > p_mlp, IntValuedEnum<LibvlcLibrary.libvlc_playback_mode_t > e_mode);
    /**
     * Create an new Media Library object<br>
     * \param p_instance the libvlc instance<br>
     * \return a new object or NULL on error<br>
     * Original signature : <code>libvlc_media_library_t* libvlc_media_library_new(libvlc_instance_t*)</code><br>
     * <i>native declaration : line 3901</i>
     */
    public static native Pointer<LibvlcLibrary.libvlc_media_library_t > libvlc_media_library_new(Pointer<LibvlcLibrary.libvlc_instance_t > p_instance);
    /**
     * Release media library object. This functions decrements the<br>
     * reference count of the media library object. If it reaches 0,<br>
     * then the object will be released.<br>
     * \param p_mlib media library object<br>
     * Original signature : <code>void libvlc_media_library_release(libvlc_media_library_t*)</code><br>
     * <i>native declaration : line 3911</i>
     */
    public static native void libvlc_media_library_release(Pointer<LibvlcLibrary.libvlc_media_library_t > p_mlib);
    /**
     * Retain a reference to a media library object. This function will<br>
     * increment the reference counting for this object. Use<br>
     * libvlc_media_library_release() to decrement the reference count.<br>
     * \param p_mlib media library object<br>
     * Original signature : <code>void libvlc_media_library_retain(libvlc_media_library_t*)</code><br>
     * <i>native declaration : line 3921</i>
     */
    public static native void libvlc_media_library_retain(Pointer<LibvlcLibrary.libvlc_media_library_t > p_mlib);
    /**
     * Load media library.<br>
     * \param p_mlib media library object<br>
     * \return 0 on success, -1 on error<br>
     * Original signature : <code>int libvlc_media_library_load(libvlc_media_library_t*)</code><br>
     * <i>native declaration : line 3930</i>
     */
    public static native int libvlc_media_library_load(Pointer<LibvlcLibrary.libvlc_media_library_t > p_mlib);
    /**
     * Get media library subitems.<br>
     * \param p_mlib media library object<br>
     * \return media list subitems<br>
     * Original signature : <code>libvlc_media_list_t* libvlc_media_library_media_list(libvlc_media_library_t*)</code><br>
     * <i>native declaration : line 3939</i>
     */
    public static native Pointer<LibvlcLibrary.libvlc_media_list_t > libvlc_media_library_media_list(Pointer<LibvlcLibrary.libvlc_media_library_t > p_mlib);
    /**
     * \deprecated Use libvlc_media_discoverer_new() and libvlc_media_discoverer_start().<br>
     * Original signature : <code>libvlc_media_discoverer_t* libvlc_media_discoverer_new_from_name(libvlc_instance_t*, const char*)</code><br>
     * <i>native declaration : line 4002</i>
     */
    public static native Pointer<LibvlcLibrary.libvlc_media_discoverer_t > libvlc_media_discoverer_new_from_name(Pointer<LibvlcLibrary.libvlc_instance_t > p_inst, Pointer<Byte > psz_name);
    /**
     * Create a media discoverer object by name.<br>
     * After this object is created, you should attach to events in order to be<br>
     * notified of the discoverer state.<br>
     * You should also attach to media_list events in order to be notified of new<br>
     * items discovered.<br>
     * You need to call libvlc_media_discoverer_start() in order to start the<br>
     * discovery.<br>
     * \see libvlc_media_discoverer_media_list<br>
     * \see libvlc_media_discoverer_event_manager<br>
     * \see libvlc_media_discoverer_start<br>
     * \param p_inst libvlc instance<br>
     * \param psz_name service name<br>
     * \return media discover object or NULL in case of error<br>
     * \version LibVLC 3.0.0 or later<br>
     * Original signature : <code>libvlc_media_discoverer_t* libvlc_media_discoverer_new(libvlc_instance_t*, const char*)</code><br>
     * <i>native declaration : line 4026</i>
     */
    public static native Pointer<LibvlcLibrary.libvlc_media_discoverer_t > libvlc_media_discoverer_new(Pointer<LibvlcLibrary.libvlc_instance_t > p_inst, Pointer<Byte > psz_name);
    /**
     * Start media discovery.<br>
     * To stop it, call libvlc_media_discoverer_stop() or<br>
     * libvlc_media_discoverer_release() directly.<br>
     * \see libvlc_media_discoverer_stop<br>
     * \param p_mdis media discover object<br>
     * \return -1 in case of error, 0 otherwise<br>
     * \version LibVLC 3.0.0 or later<br>
     * Original signature : <code>int libvlc_media_discoverer_start(libvlc_media_discoverer_t*)</code><br>
     * <i>native declaration : line 4042</i>
     */
    public static native int libvlc_media_discoverer_start(Pointer<LibvlcLibrary.libvlc_media_discoverer_t > p_mdis);
    /**
     * Stop media discovery.<br>
     * \see libvlc_media_discoverer_start<br>
     * \param p_mdis media discover object<br>
     * \version LibVLC 3.0.0 or later<br>
     * Original signature : <code>void libvlc_media_discoverer_stop(libvlc_media_discoverer_t*)</code><br>
     * <i>native declaration : line 4053</i>
     */
    public static native void libvlc_media_discoverer_stop(Pointer<LibvlcLibrary.libvlc_media_discoverer_t > p_mdis);
    /**
     * Release media discover object. If the reference count reaches 0, then<br>
     * the object will be released.<br>
     * \param p_mdis media service discover object<br>
     * Original signature : <code>void libvlc_media_discoverer_release(libvlc_media_discoverer_t*)</code><br>
     * <i>native declaration : line 4062</i>
     */
    public static native void libvlc_media_discoverer_release(Pointer<LibvlcLibrary.libvlc_media_discoverer_t > p_mdis);
    /**
     * Get media service discover object its localized name.<br>
     * \param p_mdis media discover object<br>
     * \return localized name<br>
     * Original signature : <code>char* libvlc_media_discoverer_localized_name(libvlc_media_discoverer_t*)</code><br>
     * <i>native declaration : line 4070</i>
     */
    public static native Pointer<Byte > libvlc_media_discoverer_localized_name(Pointer<LibvlcLibrary.libvlc_media_discoverer_t > p_mdis);
    /**
     * Get media service discover media list.<br>
     * \param p_mdis media service discover object<br>
     * \return list of media items<br>
     * Original signature : <code>libvlc_media_list_t* libvlc_media_discoverer_media_list(libvlc_media_discoverer_t*)</code><br>
     * <i>native declaration : line 4078</i>
     */
    public static native Pointer<LibvlcLibrary.libvlc_media_list_t > libvlc_media_discoverer_media_list(Pointer<LibvlcLibrary.libvlc_media_discoverer_t > p_mdis);
    /**
     * Get event manager from media service discover object.<br>
     * \param p_mdis media service discover object<br>
     * \return event manager object.<br>
     * Original signature : <code>libvlc_event_manager_t* libvlc_media_discoverer_event_manager(libvlc_media_discoverer_t*)</code><br>
     * <i>native declaration : line 4086</i>
     */
    public static native Pointer<LibvlcLibrary.libvlc_event_manager_t > libvlc_media_discoverer_event_manager(Pointer<LibvlcLibrary.libvlc_media_discoverer_t > p_mdis);
    /**
     * Query if media service discover object is running.<br>
     * \param p_mdis media service discover object<br>
     * \return true if running, false if not<br>
     * \libvlc_return_bool<br>
     * Original signature : <code>int libvlc_media_discoverer_is_running(libvlc_media_discoverer_t*)</code><br>
     * <i>native declaration : line 4097</i>
     */
    public static native int libvlc_media_discoverer_is_running(Pointer<LibvlcLibrary.libvlc_media_discoverer_t > p_mdis);
    /** Undefined type */
    public static interface libvlc_media_read_cb {
        
    };
    /** Undefined type */
    public static interface libvlc_media_player_t {
        
    };
    /** Undefined type */
    public static interface libvlc_media_discoverer_t {
        
    };
    /** Undefined type */
    public static interface libvlc_log_iterator_t {
        
    };
    /** Undefined type */
    public static interface libvlc_event_t {
        
    };
    /** Undefined type */
    public static interface libvlc_media_library_t {
        
    };
    /** Undefined type */
    public static interface libvlc_media_t {
        
    };
    /** Undefined type */
    public static interface vlc_log_t {
        
    };
    /** Undefined type */
    public static interface libvlc_instance_t {
        
    };
    /** Undefined type */
    public static interface libvlc_media_list_player_t {
        
    };
    /** Undefined type */
    public static interface libvlc_event_manager_t {
        
    };
    /** Undefined type */
    public static interface FILE {
        
    };
    /** Undefined type */
    public static interface libvlc_equalizer_t {
        
    };
    /** Undefined type */
    public static interface libvlc_media_list_t {
        
    };
}

